"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[5889],{3905:function(n,e,t){t.d(e,{Zo:function(){return l},kt:function(){return d}});var a=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,a,r=function(n,e){if(null==n)return{};var t,a,r={},o=Object.keys(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var u=a.createContext({}),c=function(n){var e=a.useContext(u),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},l=function(n){var e=c(n.components);return a.createElement(u.Provider,{value:e},n.children)},m={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},p=a.forwardRef((function(n,e){var t=n.components,r=n.mdxType,o=n.originalType,u=n.parentName,l=s(n,["components","mdxType","originalType","parentName"]),p=c(t),d=r,g=p["".concat(u,".").concat(d)]||p[d]||m[d]||o;return t?a.createElement(g,i(i({ref:e},l),{},{components:t})):a.createElement(g,i({ref:e},l))}));function d(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var o=t.length,i=new Array(o);i[0]=p;var s={};for(var u in e)hasOwnProperty.call(e,u)&&(s[u]=e[u]);s.originalType=n,s.mdxType="string"==typeof n?n:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},9113:function(n,e,t){t.r(e),t.d(e,{assets:function(){return l},contentTitle:function(){return u},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return m}});var a=t(3117),r=t(102),o=(t(7294),t(3905)),i=["components"],s={sidebar_position:5,title:"Make Move"},u="Make Move",c={unversionedId:"cruiser/walkthrough/instructions/make_move",id:"cruiser/walkthrough/instructions/make_move",title:"Make Move",description:"Our final instruction will be the culmination of all we've learned. We'll be making the actual game moves. This instruction is more algorithm heavy but contains a bit of everything but initialization. Handling ties is out of scope for this tutorial.",source:"@site/docs/cruiser/walkthrough/instructions/make_move.md",sourceDirName:"cruiser/walkthrough/instructions",slug:"/cruiser/walkthrough/instructions/make_move",permalink:"/docs/cruiser/walkthrough/instructions/make_move",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/walkthrough/instructions/make_move.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Make Move"},sidebar:"tutorialSidebar",previous:{title:"Forfeit Game",permalink:"/docs/cruiser/walkthrough/instructions/forfeit_game"},next:{title:"Further Topics",permalink:"/docs/cruiser/walkthrough/Further Topics"}},l={},m=[{value:"Definition",id:"definition",level:2},{value:"Processor",id:"processor",level:2},{value:"Add to <code>InstructionList</code>",id:"add-to-instructionlist",level:2},{value:"CPI",id:"cpi",level:2},{value:"Client",id:"client",level:2},{value:"Tests",id:"tests",level:2},{value:"Finished",id:"finished",level:2}],p={toc:m};function d(n){var e=n.components,t=(0,r.Z)(n,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"make-move"},"Make Move"),(0,o.kt)("p",null,"Our final instruction will be the culmination of all we've learned. We'll be making the actual game moves. This instruction is more algorithm heavy but contains a bit of everything but initialization. Handling ties is out of scope for this tutorial."),(0,o.kt)("p",null,"It will handle the player making a move and if they win it will close the game transferring the full wager to them."),(0,o.kt)("h2",{id:"definition"},"Definition"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::accounts::{CurrentWinner, Player, Space};\nuse crate::pda::GameSignerSeeder;\nuse crate::{Game, PlayerProfile, TutorialAccounts};\nuse cruiser::prelude::*;\n\n/// Makes a move on the board and handles wins.\n#[derive(Debug)]\npub enum MakeMove {}\n\nimpl<AI> Instruction<AI> for MakeMove {\n    type Accounts = MakeMoveAccounts<AI>;\n    type Data = MakeMoveData;\n    type ReturnType = ();\n}\n\n/// Accounts for [`MakeMove`]\n#[derive(AccountArgument, Debug)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[validate(data = (mov: MakeMoveData), custom = is_valid_move(&*self.game, &mov))]\npub struct MakeMoveAccounts<AI> {\n    /// The authority for the player\n    #[validate(signer)]\n    pub authority: AI,\n    /// The player to make a move for\n    #[validate(writable, custom = &self.player_profile.authority == self.authority.key())]\n    pub player_profile: DataAccount<AI, TutorialAccounts, PlayerProfile>,\n    /// The game to make a move on.\n    #[validate(\n        writable,\n        custom = self.game.is_started(),\n        custom = match self.game.next_play {\n            Player::One => &self.game.player1 == self.player_profile.info().key(),\n            Player::Two => &self.game.player2 == self.player_profile.info().key(),\n        },\n    )]\n    pub game: Box<DataAccount<AI, TutorialAccounts, Game>>,\n    /// The signer for the game.\n    /// Only needed if will win the game.\n    #[validate(\n        writable(IfSome),\n        data = IfSomeArg((GameSignerSeeder{ game: *self.game.info().key() }, self.game.signer_bump)),\n    )]\n    pub game_signer: Option<Seeds<AI, GameSignerSeeder>>,\n    /// The other player's profile.\n    /// Only needed if will win the game.\n    #[validate(\n        writable(IfSome),\n        custom = match (self.other_profile.as_ref(), self.game.next_play) {\n            (Some(profile), Player::One) => &self.game.player2 == profile.info().key(),\n            (Some(profile), Player::Two) => &self.game.player1 == profile.info().key(),\n            _ => true,\n        },\n    )]\n    pub other_profile: Option<DataAccount<AI, TutorialAccounts, PlayerProfile>>,\n    /// Only needed if will win the game.\n    #[validate(writable(IfSome))]\n    pub funds_to: Option<AI>,\n    /// Only needed if will win the game.\n    pub system_program: Option<SystemProgram<AI>>,\n}\n\n/// Data for [`MakeMove`]\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]\npub struct MakeMoveData {\n    /// Index on the big board\n    pub big_board: [u8; 2],\n    /// Index on the small board\n    pub small_board: [u8; 2],\n}\n\nfn is_valid_move(game: &Game, mov: &MakeMoveData) -> bool {\n    // Verify valid with last move\n    (game.last_move == [3, 3]\n        || game.board.get(game.last_move).map_or(false, |board| {\n            board.current_winner().is_some() || mov.big_board == game.last_move\n        }))\n        && game\n            .board\n            .get(mov.big_board)\n            .and_then(|board| {\n                board\n                    .get(mov.small_board)\n                    .map(|space| space == &Space::Empty)\n            })\n            .unwrap_or(false)\n}\n")),(0,o.kt)("h2",{id:"processor"},"Processor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(feature = "processor")]\nmod processor {\n    use super::*;\n    use crate::accounts::CurrentWinner;\n    use cruiser::solana_program::clock::Clock;\n\n    impl<\'a, AI> InstructionProcessor<AI, MakeMove> for MakeMove\n    where\n        AI: ToSolanaAccountInfo<\'a>,\n    {\n        type FromAccountsData = ();\n        type ValidateData = MakeMoveData;\n        type InstructionData = MakeMoveData;\n\n        fn data_to_instruction_arg(\n            data: <MakeMove as Instruction<AI>>::Data,\n        ) -> CruiserResult<(\n            Self::FromAccountsData,\n            Self::ValidateData,\n            Self::InstructionData,\n        )> {\n            Ok(((), data.clone(), data))\n        }\n\n        fn process(\n            _program_id: &Pubkey,\n            data: Self::InstructionData,\n            accounts: &mut <MakeMove as Instruction<AI>>::Accounts,\n        ) -> CruiserResult<<MakeMove as Instruction<AI>>::ReturnType> {\n            let next_play = accounts.game.next_play;\n            accounts\n                .game\n                .board\n                .make_move(next_play, (data.big_board, (data.small_board, ())))?;\n\n            if accounts.game.board.current_winner() == Some(accounts.game.next_play) {\n                let game_signer = accounts.game_signer.as_mut().ok_or(GenericError::Custom {\n                    error: "no game_signer on win".to_string(),\n                })?;\n                let other_profile =\n                    accounts\n                        .other_profile\n                        .as_mut()\n                        .ok_or(GenericError::Custom {\n                            error: "no other_profile on win".to_string(),\n                        })?;\n                let funds_to = accounts.funds_to.as_ref().ok_or(GenericError::Custom {\n                    error: "no funds_to on win".to_string(),\n                })?;\n                let system_program =\n                    accounts\n                        .system_program\n                        .as_ref()\n                        .ok_or(GenericError::Custom {\n                            error: "no system_program on win".to_string(),\n                        })?;\n\n                let signer_seeds = game_signer.take_seed_set().unwrap();\n                let winnings = *game_signer.lamports();\n\n                system_program.transfer(\n                    CPIChecked,\n                    game_signer.info(),\n                    funds_to,\n                    winnings,\n                    [&signer_seeds],\n                )?;\n\n                // Burn game data\n                accounts.game.player1 = SystemProgram::<()>::KEY;\n                accounts.game.player2 = SystemProgram::<()>::KEY;\n\n                // Update profiles\n                accounts.player_profile.wins.saturating_add_assign(1);\n                other_profile.losses.saturating_add_assign(1);\n\n                accounts\n                    .player_profile\n                    .lamports_won\n                    .saturating_add_assign(winnings);\n                other_profile.lamports_lost.saturating_add_assign(winnings);\n\n                // Close game\n                let mut game_lamports = game_signer.lamports_mut();\n                *funds_to.lamports_mut() += *game_lamports;\n                *game_lamports = 0;\n            } else {\n                accounts.game.next_play = match accounts.game.next_play {\n                    Player::One => Player::Two,\n                    Player::Two => Player::One,\n                };\n\n                accounts.game.last_turn = Clock::get()?.unix_timestamp;\n                accounts.game.last_move = data.small_board;\n            }\n\n            Ok(())\n        }\n    }\n}\n')),(0,o.kt)("h2",{id:"add-to-instructionlist"},"Add to ",(0,o.kt)("inlineCode",{parentName:"h2"},"InstructionList")),(0,o.kt)("p",null,"Add the following to ",(0,o.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, InstructionList, Copy, Clone)]\n#[instruction_list(\n    account_list = TutorialAccounts,\n    account_info = [<'a, AI> AI where AI: ToSolanaAccountInfo<'a>],\n    discriminant_type = u8,\n)]\npub enum TutorialInstructions {\n    /// Creates a new player profile.\n    #[instruction(instruction_type = instructions::CreateProfile)]\n    CreateProfile,\n    /// Create a new game.\n    #[instruction(instruction_type = instructions::CreateGame)]\n    CreateGame,\n    /// Join a game.\n    #[instruction(instruction_type = instructions::JoinGame)]\n    JoinGame,\n    /// Forfeits another player from a game\n    #[instruction(instruction_type = instructions::ForfeitGame)]\n    ForfeitGame,\n    /// Makes a move.\n    #[instruction(instruction_type = instructions::MakeMove)]\n    MakeMove,\n}\n")),(0,o.kt)("h2",{id:"cpi"},"CPI"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"cpi\")]\npub use cpi::*;\n\n/// CPI for [`MakeMove`]\n#[cfg(feature = \"cpi\")]\nmod cpi {\nuse super::*;\nuse crate::TutorialInstructions;\n\n    /// Makes a move\n    #[derive(Debug)]\n    pub struct MakeMoveCPI<'a, AI, const N: usize> {\n        accounts: [MaybeOwned<'a, AI>; N],\n        data: Vec<u8>,\n    }\n    impl<'a, AI> MakeMoveCPI<'a, AI, 3> {\n        /// Makes a move that won't win the game\n        pub fn new(\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            player_profile: impl Into<MaybeOwned<'a, AI>>,\n            game: impl Into<MaybeOwned<'a, AI>>,\n            make_move_data: MakeMoveData,\n        ) -> CruiserResult<MakeMoveCPI<'a, AI, 3>> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<MakeMove>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            make_move_data.serialize(&mut data)?;\n            Ok(MakeMoveCPI {\n                accounts: [authority.into(), player_profile.into(), game.into()],\n                data,\n            })\n        }\n    }\n    impl<'a, AI> MakeMoveCPI<'a, AI, 7> {\n        /// Makes a move that will win the game\n        #[allow(clippy::too_many_arguments)]\n        pub fn new_win(\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            player_profile: impl Into<MaybeOwned<'a, AI>>,\n            game: impl Into<MaybeOwned<'a, AI>>,\n            game_signer: impl Into<MaybeOwned<'a, AI>>,\n            other_profile: impl Into<MaybeOwned<'a, AI>>,\n            funds_to: impl Into<MaybeOwned<'a, AI>>,\n            system_program: impl Into<MaybeOwned<'a, AI>>,\n            make_move_data: MakeMoveData,\n        ) -> CruiserResult<MakeMoveCPI<'a, AI, 7>> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<MakeMove>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            make_move_data.serialize(&mut data)?;\n            Ok(MakeMoveCPI {\n                accounts: [\n                    authority.into(),\n                    player_profile.into(),\n                    game.into(),\n                    game_signer.into(),\n                    other_profile.into(),\n                    funds_to.into(),\n                    system_program.into(),\n                ],\n                data,\n            })\n        }\n    }\n\n    impl<'a, AI> CPIClientStatic<'a, 4> for MakeMoveCPI<'a, AI, 3>\n    where\n        AI: ToSolanaAccountMeta,\n    {\n        type InstructionList = TutorialInstructions;\n        type Instruction = MakeMove;\n        type AccountInfo = AI;\n\n        fn instruction(\n            self,\n            program_account: impl Into<MaybeOwned<'a, Self::AccountInfo>>,\n        ) -> InstructionAndAccounts<[MaybeOwned<'a, Self::AccountInfo>; 4]> {\n            let program_account = program_account.into();\n            let instruction = SolanaInstruction {\n                program_id: *program_account.meta_key(),\n                accounts: self\n                    .accounts\n                    .iter()\n                    .map(MaybeOwned::as_ref)\n                    .map(AI::to_solana_account_meta)\n                    .collect(),\n                data: self.data,\n            };\n            let mut accounts = self.accounts.into_iter();\n            InstructionAndAccounts {\n                instruction,\n                accounts: [\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    program_account,\n                ],\n            }\n        }\n    }\n\n    impl<'a, AI> CPIClientStatic<'a, 8> for MakeMoveCPI<'a, AI, 7>\n    where\n        AI: ToSolanaAccountMeta,\n    {\n        type InstructionList = TutorialInstructions;\n        type Instruction = MakeMove;\n        type AccountInfo = AI;\n\n        fn instruction(\n            self,\n            program_account: impl Into<MaybeOwned<'a, Self::AccountInfo>>,\n        ) -> InstructionAndAccounts<[MaybeOwned<'a, Self::AccountInfo>; 8]> {\n            let program_account = program_account.into();\n            let instruction = SolanaInstruction {\n                program_id: *program_account.meta_key(),\n                accounts: self\n                    .accounts\n                    .iter()\n                    .map(MaybeOwned::as_ref)\n                    .map(AI::to_solana_account_meta)\n                    .collect(),\n                data: self.data,\n            };\n            let mut accounts = self.accounts.into_iter();\n            InstructionAndAccounts {\n                instruction,\n                accounts: [\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    program_account,\n                ],\n            }\n        }\n    }\n}\n")),(0,o.kt)("h2",{id:"client"},"Client"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"client\")]\npub use client::*;\n\n/// Client for [`MakeMove`]\n#[cfg(feature = \"client\")]\nmod client {\n    use super::*;\n\n    /// Makes a non-winning move\n    pub fn make_move<'a>(\n        program_id: Pubkey,\n        authority: impl Into<HashedSigner<'a>>,\n        player_profile: Pubkey,\n        game: Pubkey,\n        move_data: MakeMoveData,\n    ) -> InstructionSet<'a> {\n        let authority = authority.into();\n        InstructionSet {\n            instructions: vec![\n                MakeMoveCPI::new(\n                    SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                    SolanaAccountMeta::new_readonly(player_profile, false),\n                    SolanaAccountMeta::new(game, false),\n                    move_data,\n                )\n                    .unwrap()\n                    .instruction(SolanaAccountMeta::new_readonly(program_id, true))\n                    .instruction,\n            ],\n            signers: [authority].into_iter().collect(),\n        }\n    }\n\n    /// Makes a winning move\n    #[allow(clippy::too_many_arguments)]\n    pub fn make_winning_move<'a>(\n        program_id: Pubkey,\n        authority: impl Into<HashedSigner<'a>>,\n        player_profile: Pubkey,\n        game: Pubkey,\n        game_signer_bump: u8,\n        other_profile: Pubkey,\n        funds_to: Pubkey,\n        move_data: MakeMoveData,\n    ) -> InstructionSet<'a> {\n        let authority = authority.into();\n        InstructionSet {\n            instructions: vec![\n                MakeMoveCPI::new_win(\n                    SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                    SolanaAccountMeta::new(player_profile, false),\n                    SolanaAccountMeta::new(game, false),\n                    SolanaAccountMeta::new(\n                        GameSignerSeeder { game }\n                            .create_address(&program_id, game_signer_bump)\n                            .unwrap(),\n                        false,\n                    ),\n                    SolanaAccountMeta::new(other_profile, false),\n                    SolanaAccountMeta::new(funds_to, false),\n                    SolanaAccountMeta::new_readonly(SystemProgram::<()>::KEY, false),\n                    move_data,\n                )\n                    .unwrap()\n                    .instruction(SolanaAccountMeta::new_readonly(program_id, true))\n                    .instruction,\n            ],\n            signers: [authority].into_iter().collect(),\n        }\n    }\n}\n")),(0,o.kt)("h2",{id:"tests"},"Tests"),(0,o.kt)("p",null,"Add the following to your ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/instructions/mod.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod make_move;\n")),(0,o.kt)("p",null,"Then we create ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/instructions/make_move.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::instructions::setup_validator;\nuse cruiser::prelude::*;\nuse cruiser_tutorial::accounts::{Game, Player, Space};\nuse cruiser_tutorial::instructions::{\n    create_game, create_profile, join_game, make_move, CreateGameClientData, MakeMoveData,\n};\nuse cruiser_tutorial::pda::GameSignerSeeder;\nuse cruiser_tutorial::TutorialAccounts;\nuse std::error::Error;\nuse std::time::Duration;\n\n#[tokio::test]\nasync fn make_move_test() -> Result<(), Box<dyn Error>> {\n    let guard = setup_validator().await;\n\n    let rpc = guard.rpc();\n    let funder = Keypair::new();\n\n    // Airdrop SOL to the funder\n    let blockhash = rpc.get_latest_blockhash().await?;\n    let sig = rpc\n        .request_airdrop_with_blockhash(&funder.pubkey(), LAMPORTS_PER_SOL * 10, &blockhash)\n        .await?;\n    rpc.confirm_transaction_with_spinner(&sig, &blockhash, CommitmentConfig::confirmed())\n        .await?;\n\n    // Create random authority and profile\n    let authority1 = Keypair::new();\n    let profile1 = Keypair::new();\n    let authority2 = Keypair::new();\n    let profile2 = Keypair::new();\n    let game = Keypair::new();\n\n    let (sig, result) = TransactionBuilder::new(&funder)\n        .signed_instructions(create_profile(\n            guard.program_id(),\n            &authority1,\n            &profile1,\n            &funder,\n        ))\n        .signed_instructions(create_profile(\n            guard.program_id(),\n            &authority2,\n            &profile2,\n            &funder,\n        ))\n        .signed_instructions(create_game(\n            guard.program_id(),\n            &authority1,\n            profile1.pubkey(),\n            &game,\n            &funder,\n            &funder,\n            Some(profile2.pubkey()),\n            CreateGameClientData {\n                creator_player: Player::One,\n                wager: LAMPORTS_PER_SOL,\n                turn_length: 60 * 60 * 24, // 1 day\n            },\n        ))\n        .signed_instructions(join_game(\n            guard.program_id(),\n            &authority2,\n            profile2.pubkey(),\n            game.pubkey(),\n            GameSignerSeeder {\n                game: game.pubkey(),\n            }\n            .find_address(&guard.program_id())\n            .1,\n            &funder,\n        ))\n        .signed_instructions(make_move(\n            guard.program_id(),\n            &authority1,\n            profile1.pubkey(),\n            game.pubkey(),\n            MakeMoveData {\n                big_board: [0, 0],\n                small_board: [0, 0],\n            },\n        ))\n        .send_and_confirm_transaction(\n            rpc,\n            RpcSendTransactionConfig {\n                skip_preflight: false,\n                preflight_commitment: Some(CommitmentLevel::Confirmed),\n                encoding: None,\n                max_retries: None,\n            },\n            CommitmentConfig::confirmed(),\n            Duration::from_millis(500),\n        )\n        .await?;\n\n    // Check result\n    match result {\n        ConfirmationResult::Success => {}\n        ConfirmationResult::Failure(error) => return Err(error.into()),\n        ConfirmationResult::Dropped => return Err("Transaction dropped".into()),\n    }\n\n    // Print logs for debugging\n    println!(\n        "Logs: {:#?}",\n        rpc.get_transaction_with_config(\n            &sig,\n            RpcTransactionConfig {\n                encoding: None,\n                commitment: Some(CommitmentConfig::confirmed()),\n                max_supported_transaction_version: None\n            }\n        )\n        .await?\n        .transaction\n        .meta\n        .unwrap()\n        .log_messages\n    );\n\n    // Check account data is what we expect\n    let account = rpc\n        .get_account_with_commitment(&game.pubkey(), CommitmentConfig::confirmed())\n        .await?\n        .value\n        .unwrap_or_else(|| {\n            panic!("Account not found");\n        });\n    let mut data = account.data.as_slice();\n    let discriminant =\n        <TutorialAccounts as AccountList>::DiscriminantCompressed::deserialize(&mut data)?;\n    assert_eq!(\n        discriminant,\n        <TutorialAccounts as AccountListItem<Game>>::compressed_discriminant()\n    );\n    let game: Game = Game::deserialize(&mut data)?;\n    assert!(game.last_turn > 0);\n    let mut expected = Game::new(\n        &profile1.pubkey(),\n        Player::One,\n        game.signer_bump,\n        LAMPORTS_PER_SOL,\n        60 * 60 * 24,\n    );\n    expected.player2 = profile2.pubkey();\n    expected.last_turn = game.last_turn;\n    expected.next_play = Player::Two;\n    expected.last_move = [0, 0];\n    *expected\n        .board\n        .get_mut([0, 0])\n        .unwrap()\n        .get_mut([0, 0])\n        .unwrap() = Space::PlayerOne;\n\n    assert_eq!(game, expected);\n\n    guard.drop_self().await;\n    Ok(())\n}\n')),(0,o.kt)("p",null,"This test should execute without error. To run it you can either run ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client --test all_tests instructions::make_move::make_move_test -- --exact")," to run only this test."),(0,o.kt)("h2",{id:"finished"},"Finished"),(0,o.kt)("p",null,"After this our program is complete on-chain!"))}d.isMDXComponent=!0}}]);