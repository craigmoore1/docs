"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[4429],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8997:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return p}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:1},l="Create Profile",u={unversionedId:"cruiser/walkthrough/instructions/Create Profile",id:"cruiser/walkthrough/instructions/Create Profile",title:"Create Profile",description:"First we will make the create_profile instruction. The purpose of this instruction is simply to make a PlayerProfile account.",source:"@site/docs/cruiser/walkthrough/instructions/Create Profile.md",sourceDirName:"cruiser/walkthrough/instructions",slug:"/cruiser/walkthrough/instructions/Create Profile",permalink:"/docs/cruiser/walkthrough/instructions/Create Profile",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/walkthrough/instructions/Create Profile.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Instructions",permalink:"/docs/cruiser/walkthrough/instructions/"},next:{title:"Create Game",permalink:"/docs/cruiser/walkthrough/instructions/Create Game"}},c={},p=[{value:"Definition",id:"definition",level:2},{value:"Processor",id:"processor",level:2},{value:"Add to InstructionList",id:"add-to-instructionlist",level:2},{value:"Create CPI Helper Functions",id:"create-cpi-helper-functions",level:2},{value:"Client",id:"client",level:2},{value:"Tests",id:"tests",level:2},{value:"<code>tests/instructions/mod.rs</code>",id:"testsinstructionsmodrs",level:3},{value:"<code>tests/instructions/create_profile.rs</code>",id:"testsinstructionscreate_profilers",level:3}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"create-profile"},"Create Profile"),(0,o.kt)("p",null,"First we will make the ",(0,o.kt)("inlineCode",{parentName:"p"},"create_profile")," instruction. The purpose of this instruction is simply to make a ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerProfile")," account."),(0,o.kt)("p",null,"We'll create and edit the ",(0,o.kt)("inlineCode",{parentName:"p"},"src/instructions/create_profile.rs")," file. Don't forget to uncomment the import in ",(0,o.kt)("inlineCode",{parentName:"p"},"src/instructions/mod.rs"),"."),(0,o.kt)("h2",{id:"definition"},"Definition"),(0,o.kt)("p",null,"We'll add the definition to the file. Here's the definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::{PlayerProfile, TutorialAccounts};\nuse cruiser::prelude::*;\n\n/// Creates a new player profile.\n#[derive(Debug)]\npub enum CreateProfile {}\n\nimpl<AI> Instruction<AI> for CreateProfile {\n    type Accounts = CreateProfileAccounts<AI>;\n    type Data = CreateProfileData;\n    type ReturnType = ();\n}\n\n/// Accounts for [`CreateProfile`]\n#[derive(AccountArgument, Debug)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[validate(generics = [<'a> where AI: ToSolanaAccountInfo<'a>])]\npub struct CreateProfileAccounts<AI> {\n    /// The authority for the new profile.\n    #[validate(signer)]\n    pub authority: AI,\n    /// The new profile to create\n    #[from(data = PlayerProfile::new(authority.key()))] // This is where we set the initial value of the profile\n    #[validate(data = InitArgs{\n        system_program: &self.system_program,\n        space: InitStaticSized,\n        funder: &self.funder,\n        funder_seeds: None,\n        account_seeds: None,\n        rent: None,\n        cpi: CPIChecked,\n    })]\n    pub profile: InitAccount<AI, TutorialAccounts, PlayerProfile>,\n    /// The funder for the new account. Needed if the account is not zeroed.\n    #[validate(signer, writable)]\n    pub funder: AI,\n    /// The system program. Needed if the account is not zeroed.\n    pub system_program: SystemProgram<AI>,\n}\n\n/// Data for [`CreateProfile`]\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]\npub struct CreateProfileData {}\n")),(0,o.kt)("p",null,"Let's break this down."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// Creates a new player profile.\n#[derive(Debug)]\npub enum CreateProfile {}\n")),(0,o.kt)("p",null,"Here we create a type to represent the instruction. Instructions in cruiser are a bunch of static functions, so we use an un-buildable enum. It would also be valid to use any other type as ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," is never referenced for the instruction. Unit structs (",(0,o.kt)("inlineCode",{parentName:"p"},"pub struct CreateProfile;"),") are also common."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// Accounts for [`CreateProfile`]\n#[derive(AccountArgument, Debug)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[validate(generics = [<'a> where AI: ToSolanaAccountInfo<'a>])] // <- Validate generic usage\npub struct CreateProfileAccounts<AI> {\n")),(0,o.kt)("p",null,"Here we see a usage of generics in our validation logic. The ",(0,o.kt)("inlineCode",{parentName:"p"},"ToSolanaAccountInfo")," trait is used to convert an account info into the solana version for CPI calling. We don't need it for the rest of the instruction, so we minimize our requirements by putting it in the ",(0,o.kt)("inlineCode",{parentName:"p"},"validate")," attribute. It would also be valid to put it on the ",(0,o.kt)("inlineCode",{parentName:"p"},"account_argument")," attribute because it's a parent to ",(0,o.kt)("inlineCode",{parentName:"p"},"validate")," but would bubble up to other places."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The authority for the new profile.\n#[validate(signer)]\npub authority: AI,\n")),(0,o.kt)("p",null,"We require the authority for the profile to sign the creation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The new profile to create\n#[from(data = PlayerProfile::new(authority.key()))] // This is where we set the initial value of the profile\n#[validate(data = InitArgs{\n    system_program: &self.system_program,\n    space: InitStaticSized,\n    funder: &self.funder,\n    funder_seeds: None,\n    account_seeds: None,\n    rent: None,\n    cpi: CPIChecked,\n})]\npub profile: InitAccount<AI, TutorialAccounts, PlayerProfile>,\n")),(0,o.kt)("p",null,"Here is most of the logic for this instruction. The first thing to look at is the type ",(0,o.kt)("inlineCode",{parentName:"p"},"InitAccount"),". This is an account that initializes a new account from a system (empty) account. "),(0,o.kt)("p",null,"Next we look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," attribute. Here we see that the data is the initial data for the new account. ",(0,o.kt)("inlineCode",{parentName:"p"},"FromAccounts<()>")," is also implemented for this type where the data has a ",(0,o.kt)("inlineCode",{parentName:"p"},"Default")," implementation."),(0,o.kt)("p",null,"Then we look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"validate")," attribute. Here we see that the data used is a struct called ",(0,o.kt)("inlineCode",{parentName:"p"},"InitArgs"),". In reality there are many generics on this struct but those are hidden because of struct initialization. Here are the values:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"field"),(0,o.kt)("th",{parentName:"tr",align:null},"type"),(0,o.kt)("th",{parentName:"tr",align:null},"description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"system_program")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"&SystemProgram<AI>")),(0,o.kt)("td",{parentName:"tr",align:null},"The system program")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"space")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"usize")," or ",(0,o.kt)("inlineCode",{parentName:"td"},"InitStaticSized")," or ",(0,o.kt)("inlineCode",{parentName:"td"},"InitSizeWithArg<A>")),(0,o.kt)("td",{parentName:"tr",align:null},"The space to give the new account. ",(0,o.kt)("inlineCode",{parentName:"td"},"usize")," lets you set it yourself while the others calculate it.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"funder")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"&AI")),(0,o.kt)("td",{parentName:"tr",align:null},"The account that will supply the funds for the rent of the new account")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"funder_seeds")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Option<&PDASeedSet>")),(0,o.kt)("td",{parentName:"tr",align:null},"The seeds for the funder account. Should only be set if the funder is a PDA.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"account_seeds")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Option<&PDASeedSet>")),(0,o.kt)("td",{parentName:"tr",align:null},"The seeds for the new account. Should only be set if the new account is a PDA.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"rent")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Option<Rent>")),(0,o.kt)("td",{parentName:"tr",align:null},"The object to calculate the rent for the new account. If ",(0,o.kt)("inlineCode",{parentName:"td"},"None")," will use ",(0,o.kt)("inlineCode",{parentName:"td"},"Rent::get")," syscall")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"cpi")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"impl CPIMethod")),(0,o.kt)("td",{parentName:"tr",align:null},"The ",(0,o.kt)("inlineCode",{parentName:"td"},"CPIMethod")," to use for the ",(0,o.kt)("inlineCode",{parentName:"td"},"create_account")," CPI")))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CPIMethod")," allows you to pick whether to do checked CPI or unchecked CPI. Unchecked CPI is faster but does not guarantee all the accounts aren't borrowed when they could be changed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The funder for the new account. Needed if the account is not zeroed.\n#[validate(signer, writable)]\npub funder: AI,\n")),(0,o.kt)("p",null,"This is the funder. The ",(0,o.kt)("inlineCode",{parentName:"p"},"signer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"writable")," checks are technically redundant because they are checked by the CPI call, but they help latter us know what the requirements are."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The system program. Needed if the account is not zeroed.\npub system_program: SystemProgram<AI>,\n")),(0,o.kt)("p",null,"This is the system program that we will CPI into. The ",(0,o.kt)("inlineCode",{parentName:"p"},"SystemProgram")," type makes sure the account is the correct key."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// Data for [`CreateProfile`]\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]\npub struct CreateProfileData {}\n")),(0,o.kt)("p",null,"Finally, we have the data. In this case we don't need any, so we use an empty struct. It would be just as valid to use the unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," as the data type instead."),(0,o.kt)("h2",{id:"processor"},"Processor"),(0,o.kt)("p",null,"Next we'll add the instruction processing code. It's very simple in this case but there's some good parts to explain. This will be added to the end of the same file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"processor\")] // Disables compiling this code for integrators that just want to CPI.\nmod processor {\n    use super::*;\n\n    impl<'a, AI> InstructionProcessor<AI, CreateProfile> for CreateProfile\n    where\n        AI: ToSolanaAccountInfo<'a>,\n    {\n        type FromAccountsData = ();\n        type ValidateData = ();\n        type InstructionData = ();\n\n        fn data_to_instruction_arg(\n            _data: <CreateProfile as Instruction<AI>>::Data,\n        ) -> CruiserResult<(\n            Self::FromAccountsData,\n            Self::ValidateData,\n            Self::InstructionData,\n        )> {\n            // This converts the data into the 3 types that are needed for the instruction.\n            Ok(((), (), ()))\n        }\n\n        fn process(\n            _program_id: &Pubkey,\n            _data: Self::InstructionData,\n            _accounts: &mut <CreateProfile as Instruction<AI>>::Accounts,\n        ) -> CruiserResult<<CreateProfile as Instruction<AI>>::ReturnType> {\n            // We don't need any processing here, all initialization is handled in the accounts.\n            // You could do some data setting here but we handled that with the profile init.\n            Ok(())\n        }\n    }\n}\n")),(0,o.kt)("p",null,"Most of this is explained in comments, so we will only go over the trait itself."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"impl<'a, AI> InstructionProcessor<AI, CreateProfile> for CreateProfile\n")),(0,o.kt)("p",null,"We can implement ",(0,o.kt)("inlineCode",{parentName:"p"},"InstructionProcessor")," for arbitrary types. This allows others to use the same instruction and implement their own processor. It also allows publishing of the instruction definitions separately from the processing. By convention we implement ",(0,o.kt)("inlineCode",{parentName:"p"},"InstructionProcessor")," for the instruction type itself."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"type FromAccountsData = ();\ntype ValidateData = ();\ntype InstructionData = ();\n\nfn data_to_instruction_arg(\n    _data: <CreateProfile as Instruction<AI>>::Data,\n) -> CruiserResult<(\n    Self::FromAccountsData,\n    Self::ValidateData,\n    Self::InstructionData,\n)> {\n    // This converts the data into the 3 types that are needed for the instruction.\n    Ok(((), (), ()))\n}\n")),(0,o.kt)("p",null,"This is where we split the instruction data that comes in. ",(0,o.kt)("inlineCode",{parentName:"p"},"FromAccountsData")," is passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"FromAccounts")," implementation, ",(0,o.kt)("inlineCode",{parentName:"p"},"ValidateData")," is passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ValidateArgument")," implementation, and ",(0,o.kt)("inlineCode",{parentName:"p"},"InstructionData")," is passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"process")," function. Since we don't have any data theses are all ",(0,o.kt)("inlineCode",{parentName:"p"},"()"),"."),(0,o.kt)("h2",{id:"add-to-instructionlist"},"Add to InstructionList"),(0,o.kt)("p",null,"Next we need to register our instruction with our instruction list. To do this we'll add the following to the list in ",(0,o.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, InstructionList, Copy, Clone)]\n#[instruction_list(\n    account_list = TutorialAccounts,\n    account_info = [<'a, AI> AI where AI: ToSolanaAccountInfo<'a>],\n    discriminant_type = u8,\n)]\npub enum TutorialInstructions {\n    /// Creates a new player profile.\n    #[instruction(instruction_type = instructions::CreateProfile)]\n    CreateProfile,\n}\n")),(0,o.kt)("p",null,"Now we can also talk about instruction discriminants. By default ",(0,o.kt)("inlineCode",{parentName:"p"},"cruiser")," instructions are discriminated by a ",(0,o.kt)("inlineCode",{parentName:"p"},"u64")," corresponding to the enum variant. If you want a different discriminant type you can add the ",(0,o.kt)("inlineCode",{parentName:"p"},"discriminant_type")," argument to the ",(0,o.kt)("inlineCode",{parentName:"p"},"instruction_list")," attribute. The type must implement ",(0,o.kt)("inlineCode",{parentName:"p"},"CompressedNumber<u64>")," (",(0,o.kt)("inlineCode",{parentName:"p"},"u8"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"u16"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"u32")," are all valid, but you can make your own if you want to do it differently). In addition, if you want the value to be different from the default discriminant you can change it with the standard rust discriminant syntax."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, InstructionList, Copy, Clone)]\n#[instruction_list(\n    account_list = TutorialAccounts,\n    account_info = [<'a, AI> AI where AI: ToSolanaAccountInfo<'a>],\n    discriminant_type = u8, // <- Set the discriminant type to u8\n)]\npub enum TutorialInstructions {\n    /// Creates a new player profile.\n    #[instruction(instruction_type = instructions::CreateProfile)]\n    CreateProfile = 100, // <- Set the discriminant to 100\n}\n")),(0,o.kt)("h2",{id:"create-cpi-helper-functions"},"Create CPI Helper Functions"),(0,o.kt)("p",null,"Next we'll add functions to help with CPI calls to this instruction. Even if your function isn't designed with CPI in mind it's helpful to have this as it makes client code easier. We'll add the following to the instruction file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"cpi\")]\npub use cpi::*;\n/// CPI types for [`CreateProfile`]\n#[cfg(feature = \"cpi\")] // We don't need this code when compiling our program for deployment\npub mod cpi {\n    use super::*;\n    use crate::TutorialInstructions;\n\n    /// Creates a new player profile.\n    /// If the instruction could be called multiple ways we would \n    /// create more of these types or add functions to this one.\n    #[derive(Debug)]\n    pub struct CreateProfileCPI<'a, AI> {\n        // The `MaybeOwned` type allows for refs or owned values to be passed in.\n        accounts: [MaybeOwned<'a, AI>; 4],\n        // The data has to be `Vec`ed anyway for CPI so we do that here.\n        data: Vec<u8>,\n    }\n    impl<'a, AI> CreateProfileCPI<'a, AI> {\n        /// Creates a new player profile.\n        pub fn new(\n            // By taking this impl type we don't have to make our users pass \n            // in `MaybeOwned` types, just refs or owned values.\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            profile: impl Into<MaybeOwned<'a, AI>>,\n            funder: impl Into<MaybeOwned<'a, AI>>,\n            system_program: impl Into<MaybeOwned<'a, AI>>,\n        ) -> CruiserResult<Self> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<CreateProfile>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            // This will do nothing but throw an error if we update this to include more data.\n            CreateProfileData {}.serialize(&mut data)?;\n            Ok(Self {\n                accounts: [\n                    authority.into(),\n                    profile.into(),\n                    funder.into(),\n                    system_program.into(),\n                ],\n                data,\n            })\n        }\n    }\n\n    // This trait allows us to use `CruiserProgramAccount`s to easily invoke the CPI.\n    impl<'a, AI> CPIClientStatic<'a, 5> for CreateProfileCPI<'a, AI>\n    where\n        AI: ToSolanaAccountMeta,\n    {\n        type InstructionList = TutorialInstructions;\n        type Instruction = CreateProfile;\n        type AccountInfo = AI;\n\n        // Here we need to return both the instruction and the account infos for the CPI.\n        fn instruction(\n            self,\n            program_account: impl Into<MaybeOwned<'a, Self::AccountInfo>>,\n        ) -> InstructionAndAccounts<[MaybeOwned<'a, Self::AccountInfo>; 5]> {\n            let program_account = program_account.into();\n            let instruction = SolanaInstruction {\n                program_id: *program_account.meta_key(),\n                accounts: self\n                    .accounts\n                    .iter()\n                    .map(MaybeOwned::as_ref)\n                    .map(AI::to_solana_account_meta)\n                    .collect(),\n                data: self.data,\n            };\n            // This could be better but requires rust const generics to concatenate two arrays.\n            // Instead we pull out the items with the `into_iter` method.\n            let mut accounts = self.accounts.into_iter();\n            InstructionAndAccounts {\n                instruction,\n                accounts: [\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    program_account,\n                ],\n            }\n        }\n    }\n}\n")),(0,o.kt)("h2",{id:"client"},"Client"),(0,o.kt)("p",null,"Now we're going to add the client functions to the instruction. These are meant to be called by a rust client through RPC calls in either tests, stand-alone applications, or WASM in a website. We add the following to the bottom of the instruction file: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"client\")]\npub use client::*;\n/// Client functions for [`CreateProfile`]\n#[cfg(feature = \"client\")]\nmod client {\n    use super::*;\n\n    /// Creates a new player profile.\n    pub fn create_profile<'a>(\n        program_id: Pubkey,\n        // Signers are `impl Into<HashedSigner<'a>>`. Non-signers are `Pubkey`.\n        authority: impl Into<HashedSigner<'a>>,\n        profile: impl Into<HashedSigner<'a>>,\n        funder: impl Into<HashedSigner<'a>>,\n        // We don't take the system program as a parameter because we know its key.\n    ) -> InstructionSet<'a> {\n        let authority = authority.into();\n        let profile = profile.into();\n        let funder = funder.into();\n        InstructionSet {\n            instructions: vec![\n                // We use the cpi function to reduce the amount of code we need to write.\n                CreateProfileCPI::new(\n                    SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                    SolanaAccountMeta::new(profile.pubkey(), true),\n                    SolanaAccountMeta::new(funder.pubkey(), true),\n                    SolanaAccountMeta::new_readonly(SystemProgram::<()>::KEY, false),\n                )\n                    .unwrap()\n                    .instruction(SolanaAccountMeta::new_readonly(program_id, false))\n                    .instruction,\n            ],\n            signers: [authority, profile, funder].into_iter().collect(),\n        }\n    }\n}\n")),(0,o.kt)("h2",{id:"tests"},"Tests"),(0,o.kt)("p",null,"Now we can test our function. To do this we need to add a file at ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/all_tests.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod instructions;\n")),(0,o.kt)("p",null,"Then we'll add the following lines to ",(0,o.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[[test]]\nname = "all_tests"\nrequired-features = ["client"]\n')),(0,o.kt)("p",null,"This makes sure our tests only run with the client feature enabled."),(0,o.kt)("h3",{id:"testsinstructionsmodrs"},(0,o.kt)("inlineCode",{parentName:"h3"},"tests/instructions/mod.rs")),(0,o.kt)("p",null,"Next we'll add the ",(0,o.kt)("inlineCode",{parentName:"p"},"tests")," directory in with its module at ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/instructions/mod.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod create_profile;\n")),(0,o.kt)("p",null,"The reason we have to have them in a folder is because rust runs all top level test files sequentially, but we want to run a single local validator for all of our tests."),(0,o.kt)("p",null,"To this file we'll add some helpful validator setup code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use cruiser::prelude::*;\nuse futures::executor::block_on;\nuse reqwest::Client;\nuse std::cell::UnsafeCell;\nuse std::path::Path;\nuse std::sync::atomic::{AtomicIsize, Ordering};\nuse std::time::Duration;\nuse tokio::process::{Child, Command};\nuse tokio::task::{spawn_blocking, yield_now};\nuse tokio::time::sleep;\n\nstatic SETUP: Setup = Setup::new();\n\n/// All tests that need validator access should call this function\n/// and call [`TestGuard::drop_self`] when done with the validator.\npub async fn setup_validator() -> TestGuard {\n    SETUP.setup().await\n}\n\nstruct Setup {\n    test_count: AtomicIsize,\n    program_id: UnsafeCell<Option<Pubkey>>,\n    validator: UnsafeCell<Option<Child>>,\n}\nimpl Setup {\n    const fn new() -> Self {\n        Self {\n            test_count: AtomicIsize::new(0),\n            program_id: UnsafeCell::new(None),\n            validator: UnsafeCell::new(None),\n        }\n    }\n\n    async fn setup(&\'static self) -> TestGuard {\n        let mut count = self.test_count.load(Ordering::SeqCst);\n        let should_start = loop {\n            let should_start = match count {\n                -2 => panic!("Validator could not be started"),\n                -1 => {\n                    // Validator is being killed\n                    sleep(Duration::from_millis(100)).await;\n                    continue;\n                }\n                0 => true,\n                count if count > 0 => false,\n                count => panic!("Bad value for count: {}", count),\n            };\n            assert!(count >= 0);\n            match self.test_count.compare_exchange_weak(\n                count,\n                count + 1,\n                Ordering::SeqCst,\n                Ordering::SeqCst,\n            ) {\n                Ok(_) => break should_start,\n                Err(new_count) => {\n                    count = new_count;\n                    yield_now().await;\n                }\n            }\n        };\n        if should_start {\n            match start_validator().await {\n                Ok((program_id, validator)) => unsafe {\n                    *self.program_id.get() = Some(program_id);\n                    *self.validator.get() = Some(validator);\n                },\n                Err(e) => {\n                    self.test_count.store(-2, Ordering::SeqCst);\n                    panic!("Validator could not be started! Error: {}", e);\n                }\n            }\n        }\n        let out = TestGuard::new(self);\n        let client = Client::new();\n        loop {\n            if self.test_count.load(Ordering::SeqCst) == -2 {\n                panic!("Validator could not be started");\n            }\n            if client\n                .get("http://localhost:8899/health")\n                .send()\n                .await\n                .map_or(false, |res| res.status().is_success())\n            {\n                break;\n            }\n            sleep(Duration::from_millis(500)).await;\n        }\n        out\n    }\n}\nunsafe impl Sync for Setup {}\n\nasync fn start_validator() -> Result<(Pubkey, Child), Box<dyn std::error::Error>> {\n    let deploy_dir = Path::new(env!("CARGO_TARGET_TMPDIR"))\n        .parent()\n        .unwrap()\n        .join("deploy");\n    let build = Command::new("cargo")\n        .env("RUSTFLAGS", "-D warnings")\n        .arg("build-bpf")\n        .arg("--workspace")\n        .spawn()?\n        .wait()\n        .await?;\n    if !build.success() {\n        return Err(build.to_string().into());\n    }\n    let program_id = Keypair::new().pubkey();\n    println!("Program ID: `{}`", program_id);\n\n    let mut local_validator = Command::new("solana-test-validator");\n    local_validator\n        .arg("-r")\n        .arg("--bpf-program")\n        .arg(program_id.to_string())\n        .arg(deploy_dir.join(format!("{}.so", env!("CARGO_PKG_NAME"))))\n        .arg("--deactivate-feature")\n        .arg("5ekBxc8itEnPv4NzGJtr8BVVQLNMQuLMNQQj7pHoLNZ9") // transaction wide compute cap\n        .arg("--deactivate-feature")\n        .arg("75m6ysz33AfLA5DDEzWM1obBrnPQRSsdVQ2nRmc8Vuu1") // support account data reallocation\n        .arg("--ledger")\n        .arg(Path::new(env!("CARGO_TARGET_TMPDIR")).join("test_ledger"));\n\n    println!("Starting local validator...");\n    println!("{:?}", local_validator);\n    Ok((program_id, local_validator.spawn()?))\n}\n\n#[must_use]\npub struct TestGuard {\n    setup: &\'static Setup,\n    rpc: RpcClient,\n}\nimpl TestGuard {\n    fn new(setup: &\'static Setup) -> Self {\n        Self {\n            setup,\n            rpc: RpcClient::new("http://localhost:8899".to_string()),\n        }\n    }\n\n    pub fn program_id(&self) -> Pubkey {\n        unsafe { (*self.setup.program_id.get()).unwrap() }\n    }\n\n    pub fn rpc(&self) -> &RpcClient {\n        &self.rpc\n    }\n\n    pub async fn drop_self(self) {\n        spawn_blocking(move || {\n            drop(self);\n        })\n            .await\n            .unwrap();\n    }\n}\nimpl Drop for TestGuard {\n    fn drop(&mut self) {\n        block_on(async {\n            let mut count = self.setup.test_count.load(Ordering::SeqCst);\n            let should_kill = loop {\n                let (replace, should_kill) = match count {\n                    count if count < 1 => panic!("`TestGuard` dropped when count less than 1"),\n                    1 => (-1, true),\n                    count => (count - 1, false),\n                };\n                match self.setup.test_count.compare_exchange_weak(\n                    count,\n                    replace,\n                    Ordering::SeqCst,\n                    Ordering::SeqCst,\n                ) {\n                    Ok(_) => break should_kill,\n                    Err(new_count) => {\n                        count = new_count;\n                        yield_now().await;\n                    }\n                }\n            };\n            if should_kill {\n                let mut local = unsafe { (&mut *self.setup.validator.get()).take().unwrap() };\n                local.start_kill().unwrap();\n                local.wait().await.unwrap();\n                assert_eq!(self.setup.test_count.fetch_add(1, Ordering::SeqCst), -1);\n                println!("Validator cleaned up properly");\n            }\n        });\n    }\n}\n')),(0,o.kt)("p",null,"This is some code that will set up the local validator for all the tests. Notice the comment on ",(0,o.kt)("inlineCode",{parentName:"p"},"setup_validator"),"."),(0,o.kt)("h3",{id:"testsinstructionscreate_profilers"},(0,o.kt)("inlineCode",{parentName:"h3"},"tests/instructions/create_profile.rs")),(0,o.kt)("p",null,"Now we can create our actual test file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::instructions::setup_validator;\nuse cruiser::prelude::*;\nuse cruiser_tutorial::accounts::PlayerProfile;\nuse cruiser_tutorial::instructions::create_profile;\nuse cruiser_tutorial::TutorialAccounts;\nuse std::error::Error;\nuse std::time::Duration;\n\n#[tokio::test]\nasync fn create_profile_test() -> Result<(), Box<dyn Error>> {\n    let guard = setup_validator().await;\n\n    let rpc = guard.rpc();\n    let funder = Keypair::new();\n\n    // Airdrop SOL to the funder\n    let blockhash = rpc.get_latest_blockhash().await?;\n    let sig = rpc\n        .request_airdrop_with_blockhash(&funder.pubkey(), LAMPORTS_PER_SOL * 10, &blockhash)\n        .await?;\n    rpc.confirm_transaction_with_spinner(&sig, &blockhash, CommitmentConfig::confirmed())\n        .await?;\n\n    // Create random authority and profile\n    let authority = Keypair::new();\n    let profile = Keypair::new();\n\n    // Send transaction\n    let (sig, result) = TransactionBuilder::new(&funder)\n        .signed_instructions(create_profile(\n            guard.program_id(),\n            &authority,\n            &profile,\n            &funder,\n        ))\n        .send_and_confirm_transaction(\n            rpc,\n            RpcSendTransactionConfig {\n                skip_preflight: false,\n                preflight_commitment: Some(CommitmentLevel::Confirmed),\n                encoding: None,\n                max_retries: None,\n            },\n            CommitmentConfig::confirmed(),\n            Duration::from_millis(500),\n        )\n        .await?;\n\n    // Check result\n    match result {\n        ConfirmationResult::Success => {}\n        ConfirmationResult::Failure(error) => return Err(error.into()),\n        ConfirmationResult::Dropped => return Err("Transaction dropped".into()),\n    }\n\n    // Print logs for debugging\n    println!(\n        "Logs: {:#?}",\n        rpc.get_transaction_with_config(\n            &sig,\n            RpcTransactionConfig {\n                encoding: None,\n                commitment: Some(CommitmentConfig::confirmed()),\n                max_supported_transaction_version: None\n            }\n        )\n            .await?\n            .transaction\n            .meta\n            .unwrap()\n            .log_messages\n    );\n\n    // Check account data is what we expect\n    let account = rpc\n        .get_account_with_commitment(&profile.pubkey(), CommitmentConfig::confirmed())\n        .await?\n        .value\n        .unwrap_or_else(|| {\n            panic!("Account not found");\n        });\n    let mut data = account.data.as_slice();\n    let discriminant =\n        <TutorialAccounts as AccountList>::DiscriminantCompressed::deserialize(&mut data)?;\n    assert_eq!(\n        discriminant,\n        <TutorialAccounts as AccountListItem<PlayerProfile>>::compressed_discriminant()\n    );\n    let profile = PlayerProfile::deserialize(&mut data)?;\n    assert_eq!(profile, PlayerProfile::new(&authority.pubkey()));\n\n    guard.drop_self().await;\n    Ok(())\n}\n')),(0,o.kt)("p",null,"This test should execute without error. To run it you can either run ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client --test all_tests instructions::create_profile::create_profile_test -- --exact")," to run only this test."))}m.isMDXComponent=!0}}]);