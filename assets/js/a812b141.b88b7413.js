"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[9038],{3905:function(e,n,r){r.d(n,{Zo:function(){return p},kt:function(){return f}});var a=r(7294);function t(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){t(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function i(e,n){if(null==e)return{};var r,a,t=function(e,n){if(null==e)return{};var r,a,t={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var s=a.createContext({}),u=function(e){var n=a.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=u(r),f=t,y=d["".concat(s,".").concat(f)]||d[f]||c[f]||o;return r?a.createElement(y,l(l({ref:n},p),{},{components:r})):a.createElement(y,l({ref:n},p))}));function f(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=r.length,l=new Array(o);l[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:t,l[1]=i;for(var u=2;u<o;u++)l[u]=r[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},1760:function(e,n,r){r.r(n),r.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return c}});var a=r(3117),t=r(102),o=(r(7294),r(3905)),l=["components"],i={sidebar_position:3},s="Accounts",u={unversionedId:"cruiser/walkthrough/Accounts",id:"cruiser/walkthrough/Accounts",title:"Accounts",description:"The first step in designing accounts for a Solana program is defining what you want the program to do.",source:"@site/docs/cruiser/walkthrough/Accounts.md",sourceDirName:"cruiser/walkthrough",slug:"/cruiser/walkthrough/Accounts",permalink:"/docs/cruiser/walkthrough/Accounts",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/walkthrough/Accounts.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Project Setup",permalink:"/docs/cruiser/walkthrough/Project Setup"},next:{title:"Instructions",permalink:"/docs/cruiser/walkthrough/instructions/"}},p={},c=[{value:"<code>accounts</code> mod",id:"accounts-mod",level:2},{value:"<code>src/accounts/mod.rs</code>",id:"srcaccountsmodrs",level:3},{value:"Game Board",id:"game-board",level:2},{value:"<code>src/accounts/game.rs</code>",id:"srcaccountsgamers",level:3},{value:"Player Profile",id:"player-profile",level:2},{value:"<code>src/accounts/player_profile.rs</code>",id:"srcaccountsplayer_profilers",level:3}],d={toc:c};function f(e){var n=e.components,r=(0,t.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"accounts"},"Accounts"),(0,o.kt)("p",null,"The first step in designing accounts for a Solana program is defining what you want the program to do.\nIn our case we are going to build ",(0,o.kt)("a",{parentName:"p",href:"https://mathwithbaddrawings.com/2013/06/16/ultimate-tic-tac-toe/"},"Ultimate Tic-Tac-Toe"),"."),(0,o.kt)("p",null,"For this design we will need 2 accounts, one for the game board and one for the player profile. Each of these accounts will get its own file within the ",(0,o.kt)("inlineCode",{parentName:"p"},"src/accounts")," directory."),(0,o.kt)("h2",{id:"accounts-mod"},(0,o.kt)("inlineCode",{parentName:"h2"},"accounts")," mod"),(0,o.kt)("p",null,"First we'll add in the ",(0,o.kt)("inlineCode",{parentName:"p"},"accounts")," module. This requires we add the following to the top of ",(0,o.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub mod accounts;\n")),(0,o.kt)("h3",{id:"srcaccountsmodrs"},(0,o.kt)("inlineCode",{parentName:"h3"},"src/accounts/mod.rs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"//! Accounts for the program.\n\nmod game;\nmod player_profile;\n\npub use game::*;\npub use player_profile::*;\n")),(0,o.kt)("h2",{id:"game-board"},"Game Board"),(0,o.kt)("p",null,"Next we'll add in the game board account. This isn't the most efficient way to store the data, but it's a good starting point."),(0,o.kt)("h3",{id:"srcaccountsgamers"},(0,o.kt)("inlineCode",{parentName:"h3"},"src/accounts/game.rs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use cruiser::prelude::*;\n\n/// The game board.\n#[derive(Debug, BorshDeserialize, BorshSerialize, Eq, PartialEq, OnChainSize)]\npub struct Game {\n    /// The version of this account. Should always add this for future proofing.\n    /// Should be 0 until a new version is added.\n    pub version: u8,\n    /// The first player's profile.\n    pub player1: Pubkey,\n    /// The second player's profile.\n    pub player2: Pubkey,\n    /// Which player was the creator and entitled to the rent.\n    pub creator: Player,\n    /// The player to take the next move.\n    pub next_play: Player,\n    /// The bump of the signer that holds the wager.\n    pub signer_bump: u8,\n    /// The wager per player in lamports.\n    pub wager: u64,\n    /// The amount of time in seconds to play a given turn before forfeiting.\n    /// 0 means no time limit.\n    pub turn_length: UnixTimestamp,\n    /// The last turn timestamp. If 0 game is not started.\n    pub last_turn: UnixTimestamp,\n    /// The last move a player did. If `[3,3]` last move is game start.\n    pub last_move: [u8; 2],\n    /// The current board. In RC format.\n    pub board: Board<Board<Space>>,\n}\n\nimpl Game {\n    /// Creates a new game board.\n    pub fn new(\n        player_profile: &Pubkey,\n        player: Player,\n        signer_bump: u8,\n        wager: u64,\n        turn_length: UnixTimestamp,\n    ) -> Self {\n        Self {\n            version: 0,\n\n            player1: if player == Player::One {\n                *player_profile\n            } else {\n                Pubkey::new_from_array([0; 32])\n            },\n            player2: if player == Player::Two {\n                *player_profile\n            } else {\n                Pubkey::new_from_array([0; 32])\n            },\n            creator: player,\n            next_play: Player::One,\n            signer_bump,\n            wager,\n            turn_length,\n            last_turn: 0,\n            last_move: [3, 3],\n            board: Default::default(),\n        }\n    }\n\n    /// Tells whether the game has started.\n    pub fn is_started(&self) -> bool {\n        self.last_turn > 0\n    }\n\n    /// Tells whether the other player is valid to join the game.\n    pub fn is_valid_other_player(&self, other_player: &Pubkey) -> bool {\n        match self.creator {\n            Player::One => {\n                self.player2 == *other_player || self.player2 == Pubkey::new_from_array([0; 32])\n            }\n            Player::Two => {\n                self.player1 == *other_player || self.player1 == Pubkey::new_from_array([0; 32])\n            }\n        }\n    }\n}\n\n/// A player\n#[derive(Copy, Clone, Debug, BorshDeserialize, BorshSerialize, Eq, PartialEq, OnChainSize)]\npub enum Player {\n    /// Player 1\n    One,\n    /// Player 2\n    Two,\n}\n\n/// A space on the game board.\n#[derive(Copy, Clone, Debug, BorshDeserialize, BorshSerialize, Eq, PartialEq, OnChainSize)]\npub enum Space {\n    /// Player 1's space\n    PlayerOne,\n    /// Player 2's space\n    PlayerTwo,\n    /// Empty space\n    Empty,\n}\nimpl From<Player> for Space {\n    fn from(player: Player) -> Self {\n        match player {\n            Player::One => Space::PlayerOne,\n            Player::Two => Space::PlayerTwo,\n        }\n    }\n}\nimpl Default for Space {\n    fn default() -> Self {\n        Space::Empty\n    }\n}\n\n/// A sub-board. We use a generic for if we want to go crazy and add sub-sub boards!\n#[derive(Copy, Clone, Debug, BorshDeserialize, BorshSerialize, Eq, PartialEq, OnChainSize)]\n#[on_chain_size(generics = [where S: OnChainSize])]\npub enum Board<S> {\n    /// Board has no winner yet. Board is in RC format.\n    Unsolved([[S; 3]; 3]),\n    /// Board has a winner\n    Solved(Player),\n}\nimpl<S> Default for Board<S>\n    where\n        S: Default + Copy,\n{\n    fn default() -> Self {\n        Board::Unsolved([[S::default(); 3]; 3])\n    }\n}\nimpl<S> Board<S> {\n    /// Gets an index of the board if unsolved.\n    pub fn get(&self, index: [u8; 2]) -> Option<&S> {\n        match self {\n            Board::Unsolved(board) => board.get(index[0] as usize)?.get(index[1] as usize),\n            Board::Solved(_) => None,\n        }\n    }\n\n    /// Gets an index mutably of the board if unsolved.\n    pub fn get_mut(&mut self, index: [u8; 2]) -> Option<&mut S> {\n        match self {\n            Board::Unsolved(board) => board.get_mut(index[0] as usize)?.get_mut(index[1] as usize),\n            Board::Solved(_) => None,\n        }\n    }\n}\n\n/// This trait lets us use the same logic for checking winners on the sub-boards and main board.\npub trait CurrentWinner {\n    /// The index used to make a move.\n    type Index;\n\n    /// Gets the current player on the space.\n    fn current_winner(&self) -> Option<Player>;\n\n    /// Solves the current board to see if there is a winner.\n    fn make_move(&mut self, player: Player, index: Self::Index) -> CruiserResult<()>;\n}\nimpl CurrentWinner for Space {\n    // A space is the lowest level and can't be further indexed.\n    type Index = ();\n\n    fn current_winner(&self) -> Option<Player> {\n        match self {\n            Space::PlayerOne => Some(Player::One),\n            Space::PlayerTwo => Some(Player::Two),\n            Space::Empty => None,\n        }\n    }\n\n    fn make_move(&mut self, player: Player, _index: ()) -> CruiserResult<()> {\n        *self = player.into();\n        Ok(())\n    }\n}\nimpl<S> CurrentWinner for Board<S>\n    where\n        S: CurrentWinner + Copy,\n{\n    /// We set the indexer to be our index + the sub-board index.\n    type Index = ([u8; 2], S::Index);\n\n    fn current_winner(&self) -> Option<Player> {\n        match self {\n            Board::Unsolved(_) => None,\n            Board::Solved(player) => Some(*player),\n        }\n    }\n\n    fn make_move(&mut self, player: Player, index: ([u8; 2], S::Index)) -> CruiserResult<()> {\n        let (index, sub_index) = index;\n        match self {\n            Board::Unsolved(sub_board) => {\n                // We make a move on the sub board.\n                sub_board[index[0] as usize][index[1] as usize].make_move(player, sub_index)?;\n                // Now we check if we are solved.\n                if is_winner(sub_board, player) {\n                    *self = Board::Solved(player);\n                }\n                Ok(())\n            }\n            Board::Solved(_) => {\n                // Cannot make a move on a solved board.\n                // We call `into` here to turn a generic error into the even more general `CruiserError`.\n                // You would do the same with a custom error type.\n                Err(GenericError::Custom {\n                    error: \"Cannot make move on solved board\".to_string(),\n                }\n                    .into())\n            }\n        }\n    }\n}\n\n/// Gets the winner of a board. This could be a sub-board or the main board.\npub fn is_winner(board: &[[impl CurrentWinner + Copy; 3]; 3], last_turn: Player) -> bool {\n    // Check rows\n    if board.iter().any(|row| {\n        row.iter()\n            .map(CurrentWinner::current_winner)\n            .all(|winner| winner.map(|winner| winner == last_turn).unwrap_or(false))\n    }) {\n        return true;\n    }\n\n    // Check columns\n    'outer: for col in 0..board[0].len() {\n        for row in board {\n            if !matches!(row[col].current_winner(), Some(player) if player == last_turn) {\n                continue 'outer;\n            }\n        }\n        return true;\n    }\n\n    // Check diagonals\n    let mut diagonal1 = 0;\n    let mut diagonal2 = 0;\n    for index in 0..board.len() {\n        if matches!(board[index][index].current_winner(), Some(player) if player == last_turn) {\n            diagonal1 += 1;\n        }\n        if matches!(\n            board[index][board.len() - index - 1].current_winner(),\n            Some(player) if player == last_turn\n        ) {\n            diagonal2 += 1;\n        }\n    }\n    if diagonal1 == board.len() || diagonal2 == board.len() {\n        return true;\n    }\n\n    false\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    /// Simple test for our winner logic.\n    #[test]\n    fn test_get_winner() {\n        let board = [\n            [Space::PlayerOne, Space::PlayerOne, Space::PlayerOne],\n            [Space::Empty, Space::PlayerTwo, Space::PlayerTwo],\n            [Space::Empty, Space::Empty, Space::Empty],\n        ];\n        assert!(is_winner(&board, Player::One));\n        let board = [\n            [Space::PlayerTwo, Space::PlayerOne, Space::PlayerOne],\n            [Space::Empty, Space::PlayerTwo, Space::PlayerTwo],\n            [Space::Empty, Space::Empty, Space::PlayerTwo],\n        ];\n        assert!(is_winner(&board, Player::Two));\n        let board = [\n            [Space::PlayerTwo, Space::PlayerOne, Space::PlayerOne],\n            [Space::Empty, Space::PlayerTwo, Space::PlayerOne],\n            [Space::Empty, Space::Empty, Space::PlayerOne],\n        ];\n        assert!(is_winner(&board, Player::One));\n        let board = [\n            [Space::PlayerTwo, Space::PlayerOne, Space::PlayerOne],\n            [Space::Empty, Space::PlayerTwo, Space::Empty],\n            [Space::Empty, Space::Empty, Space::PlayerOne],\n        ];\n        assert!(!is_winner(&board, Player::One));\n        assert!(!is_winner(&board, Player::Two));\n    }\n}\n")),(0,o.kt)("h2",{id:"player-profile"},"Player Profile"),(0,o.kt)("p",null,"Next we'll build the player profile. This is for storing a player's stats including ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Elo_rating_system"},"ELO"),". Usually you don't want to store historical data unless you have an on-chain use for it, but it's useful for learning how you would. We also won't restrict the number of profiles for a given wallet, it's technically difficult (PDAs don't solve this without running find) and very easy to create a new wallet."),(0,o.kt)("h3",{id:"srcaccountsplayer_profilers"},(0,o.kt)("inlineCode",{parentName:"h3"},"src/accounts/player_profile.rs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use cruiser::prelude::*;\n\n/// A player's profile.\n#[derive(Debug, BorshDeserialize, BorshSerialize, PartialEq, OnChainSize)]\npub struct PlayerProfile {\n    /// The key allowed to act for this profile.\n    pub authority: Pubkey,\n    /// The number of wins this player has.\n    pub wins: u64,\n    /// The number of losses this player has.\n    pub losses: u64,\n    /// The number of draws this player has.\n    pub draws: u64,\n    /// The amount of lamports this player has won.\n    pub lamports_won: u64,\n    /// The amount of lamports this player has lost.\n    pub lamports_lost: u64,\n    /// The elo rating of the player.\n    pub elo: u64,\n}\nimpl PlayerProfile {\n    /// The initial elo for a new profile.\n    pub const INITIAL_ELO: u64 = 1200;\n\n    /// Creates a new player profile.\n    /// `authority` is a ref to a pubkey because it's more efficient to use a ref on-chain.\n    pub fn new(authority: &Pubkey) -> Self {\n        Self {\n            authority: *authority,\n            wins: 0,\n            losses: 0,\n            draws: 0,\n            lamports_won: 0,\n            lamports_lost: 0,\n            elo: Self::INITIAL_ELO,\n        }\n    }\n}\n\n/// Probability of `elo_a` winning over `elo_b`.\nfn win_probability(elo_a: f64, elo_b: f64) -> f64 {\n    1.0 / (1.0 + 10.0_f64.powf((elo_b - elo_a) / 400.0))\n}\n\n/// Calculates the new elo of players after a game.\npub fn update_elo(elo_a: &mut u64, elo_b: &mut u64, k: f64, a_won: bool) {\n    let mut elo_a_float = *elo_a as f64;\n    let mut elo_b_float = *elo_b as f64;\n    let a_prob = win_probability(elo_a_float, elo_b_float);\n    let b_prob = win_probability(elo_b_float, elo_a_float);\n\n    if a_won {\n        elo_a_float += k * (1.0 - a_prob);\n        elo_b_float += k * (0.0 - b_prob);\n    } else {\n        elo_a_float += k * (0.0 - a_prob);\n        elo_b_float += k * (1.0 - b_prob);\n    }\n\n    *elo_a = elo_a_float as u64;\n    *elo_b = elo_b_float as u64;\n}\n")))}f.isMDXComponent=!0}}]);