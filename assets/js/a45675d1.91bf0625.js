"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[4845],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return d}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(t),d=r,f=m["".concat(c,".").concat(d)]||m[d]||p[d]||o;return t?a.createElement(f,i(i({ref:n},u),{},{components:t})):a.createElement(f,i({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8442:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return p}});var a=t(3117),r=t(102),o=(t(7294),t(3905)),i=["components"],s={sidebar_position:2},c="Create Game",l={unversionedId:"cruiser/walkthrough/instructions/Create Game",id:"cruiser/walkthrough/instructions/Create Game",title:"Create Game",description:"Our next instruction will be create_game. This instruction is similar to the last but has a few more requirements:",source:"@site/docs/cruiser/walkthrough/instructions/Create Game.md",sourceDirName:"cruiser/walkthrough/instructions",slug:"/cruiser/walkthrough/instructions/Create Game",permalink:"/docs/cruiser/walkthrough/instructions/Create Game",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/walkthrough/instructions/Create Game.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Create Profile",permalink:"/docs/cruiser/walkthrough/instructions/Create Profile"},next:{title:"Join Game",permalink:"/docs/cruiser/walkthrough/instructions/Join Game"}},u={},p=[{value:"Definition",id:"definition",level:2},{value:"<code>Box</code>",id:"box",level:3},{value:"<code>ReadOnlyDataAccount</code>",id:"readonlydataaccount",level:3},{value:"<code>InitOrZeroedAccount</code>",id:"initorzeroedaccount",level:3},{value:"<code>other_player_profile</code>",id:"other_player_profile",level:3},{value:"Processor",id:"processor",level:2},{value:"Add to <code>InstructionList</code>",id:"add-to-instructionlist",level:2},{value:"CPI",id:"cpi",level:2},{value:"Client",id:"client",level:2},{value:"Tests",id:"tests",level:2}],m={toc:p};function d(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"create-game"},"Create Game"),(0,o.kt)("p",null,"Our next instruction will be ",(0,o.kt)("inlineCode",{parentName:"p"},"create_game"),". This instruction is similar to the last but has a few more requirements:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The game must be created for a profile, meaning we need to take a profile as an argument."),(0,o.kt)("li",{parentName:"ol"},"The game must take the player's wager, requiring a cpi transfer."),(0,o.kt)("li",{parentName:"ol"},"There's some data that the user selects for the game, profiles have a default data they all start with."),(0,o.kt)("li",{parentName:"ol"},"The game can optionally take another player's profile as the opponent.")),(0,o.kt)("p",null,"We will also add some more functionality than we did with ",(0,o.kt)("inlineCode",{parentName:"p"},"create_profile"),", namely allowing zeroed accounts to be inited. Zeroed accounts are owned by our program but are filled with zeroed data. The reason this is helpful is that ",(0,o.kt)("inlineCode",{parentName:"p"},"InitAccount")," has a limit to the size of account it can create (~10k) but we can create larger accounts by creating them in a separate dedicated instruction. For this instruction we will allow either method of creating accounts. We can do this easily in cruiser with ",(0,o.kt)("inlineCode",{parentName:"p"},"InitOrZeroedAccount"),"."),(0,o.kt)("h2",{id:"definition"},"Definition"),(0,o.kt)("p",null,"Lets define our instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::accounts::Player;\nuse crate::pda::GameSignerSeeder;\nuse crate::{Game, PlayerProfile, TutorialAccounts};\nuse cruiser::prelude::*;\n\n/// Creates a new game.\n#[derive(Debug)]\npub enum CreateGame {}\n\nimpl<AI> Instruction<AI> for CreateGame {\n    type Accounts = CreateGameAccounts<AI>;\n    type Data = CreateGameData;\n    type ReturnType = ();\n}\n\n/// Accounts for [`CreateGame`]\n#[derive(AccountArgument, Debug)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[from(\n    data = (create_data: CreateGameData),\n    custom = create_data.wager.checked_mul(2).is_some(),\n    custom = create_data.turn_length > 0,\n)]\n#[validate(generics = [<'a> where AI: ToSolanaAccountInfo<'a>])]\npub struct CreateGameAccounts<AI> {\n    /// The authority for the creator's profile.\n    #[validate(signer)]\n    pub authority: AI,\n    /// The creator's profile.\n    #[validate(custom = &self.player_profile.authority == self.authority.key())]\n    pub player_profile: ReadOnlyDataAccount<AI, TutorialAccounts, PlayerProfile>,\n    /// The game to be created.\n    #[from(data = Game::new(\n        player_profile.info().key(), \n        create_data.creator_player, \n        create_data.signer_bump, \n        create_data.wager, \n        create_data.turn_length,\n    ))]\n    #[validate(data = InitArgs{\n        system_program: Some(&self.system_program),\n        space: InitStaticSized,\n        funder: self.funder.as_ref(),\n        funder_seeds: None,\n        account_seeds: None,\n        rent: None,\n        cpi: CPIChecked,\n    })]\n    pub game: Box<InitOrZeroedAccount<AI, TutorialAccounts, Game>>,\n    /// The game signer that will hold the wager.\n    #[validate(writable, data = (GameSignerSeeder{ game: *self.game.info().key() }, self.game.signer_bump))]\n    pub game_signer: Seeds<AI, GameSignerSeeder>,\n    /// The funder that will put the creator's wager into the game.\n    #[validate(signer, writable)]\n    pub wager_funder: AI,\n    /// The system program for transferring the wager and initializing the game if needed.\n    pub system_program: SystemProgram<AI>,\n    /// The funder for the game's rent. Only needed if not zeroed.\n    #[from(data = game.is_init())]\n    #[validate(signer(IfSome), writable(IfSome))]\n    pub funder: Option<AI>,\n    /// If [`Some`] locks other player to a given profile.\n    pub other_player_profile: Option<ReadOnlyDataAccount<AI, TutorialAccounts, PlayerProfile>>,\n}\n\n/// Data for [`CreateGame`]\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]\npub struct CreateGameData {\n    /// Which position the creator wants to play in.\n    pub creator_player: Player,\n    /// The bump for the game signer.\n    pub signer_bump: u8,\n    /// The wager each player will place. Winner gets double this amount.\n    pub wager: u64,\n    /// The length of time each player gets to play their turn. Starts once other player joins.\n    pub turn_length: UnixTimestamp,\n}\n")),(0,o.kt)("p",null,"This instruction is a bit more complicated than the last so let's take it one step at a time, focusing on the differences."),(0,o.kt)("h3",{id:"box"},(0,o.kt)("inlineCode",{parentName:"h3"},"Box")),(0,o.kt)("p",null,"Here is the first time we see an account being boxed. This is needed because Solana has a pretty small stack and if we don't box it (put it on the heap) then we blow the stack. The error that occurs when we try to do this is an ",(0,o.kt)("inlineCode",{parentName:"p"},"access violation")," with some raw pointer addresses. If you see this try to box some of your large accounts or large stack variables."),(0,o.kt)("h3",{id:"readonlydataaccount"},(0,o.kt)("inlineCode",{parentName:"h3"},"ReadOnlyDataAccount")),(0,o.kt)("p",null,"To start lets look at one of the new account types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The creator's profile.\n#[validate(custom = &self.player_profile.authority == self.authority.key())]\npub player_profile: ReadOnlyDataAccount<AI, TutorialAccounts, PlayerProfile>,\n")),(0,o.kt)("p",null,"This type allows us to access data from an account in a read-only manner. In this case we only need to see the authority of the profile and confirm that it's the same as the authority passed in. You may also notice that this gives us access to all the data despite not needing anything but the authority, this can be solved by the ",(0,o.kt)("inlineCode",{parentName:"p"},"in_place")," feature seen in the Further Exploration section."),(0,o.kt)("h3",{id:"initorzeroedaccount"},(0,o.kt)("inlineCode",{parentName:"h3"},"InitOrZeroedAccount")),(0,o.kt)("p",null,"Next we'll look at the new initializer type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// Accounts for [`CreateGame`]\n#[derive(AccountArgument, Debug)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[from(\n    data = (create_data: CreateGameData),                   // <-- Difference\n    custom = create_data.wager.checked_mul(2).is_some(),    // <-- Difference\n    custom = create_data.turn_length > 0,                   // <-- Difference\n)] \n#[validate(generics = [<'a> where AI: ToSolanaAccountInfo<'a>])]\npub struct CreateGameAccounts<AI> {\n")),(0,o.kt)("p",null,"Here we come to our first major difference. We are adding ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," data to this struct and using custom validations on it. This will help us initialize the game here:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The game to be created.\n#[from(data = Game::new(\n    player_profile.info().key(), \n    create_data.creator_player, \n    create_data.signer_bump, \n    create_data.wager, \n    create_data.turn_length,\n))]\n#[validate(data = InitArgs{\n    system_program: Some(&self.system_program), // <- Optional now\n    space: InitStaticSized,\n    funder: self.funder.as_ref(), // <- Optional now\n    funder_seeds: None,\n    account_seeds: None,\n    rent: None,\n    cpi: CPIChecked,\n})]\npub game: Box<InitOrZeroedAccount<AI, TutorialAccounts, Game>>,\n")),(0,o.kt)("p",null,"We see that the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," data is used to build the starting value for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Game"),". We can also see the ",(0,o.kt)("inlineCode",{parentName:"p"},"InitOrZeroedAccount")," type is very similar to ",(0,o.kt)("inlineCode",{parentName:"p"},"InitAccount")," with a few key differences. The ",(0,o.kt)("inlineCode",{parentName:"p"},"InitOrZeroedAccount")," type is actually an enum of ",(0,o.kt)("inlineCode",{parentName:"p"},"InitAccount")," and another type: ",(0,o.kt)("inlineCode",{parentName:"p"},"ZeroedAccount"),". It is determined at runtime which to use based on the account's owner. ",(0,o.kt)("inlineCode",{parentName:"p"},"ZeroedAccount")," does not need initialize arguments so to bring the most compatibility ",(0,o.kt)("inlineCode",{parentName:"p"},"InitOrZeroedAccount")," uses the same ",(0,o.kt)("inlineCode",{parentName:"p"},"InitArgs")," validate argument but with each non-trivial field optional. ",(0,o.kt)("strong",{parentName:"p"},"Be aware the zeroed path does not guarantee the account size out of the box!")," In our case the size just needs to be big enough and writing will fail if it's not. This all means that we can take the account funder optionally: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The funder for the game's rent. Only needed if not zeroed.\n#[from(data = game.is_init())]\n#[validate(signer(IfSome), writable(IfSome))]\npub funder: Option<AI>,\n")),(0,o.kt)("p",null,"The funder field is only set if the ",(0,o.kt)("inlineCode",{parentName:"p"},"game.is_init()")," is true, meaning the account needs to be initialized. The ",(0,o.kt)("inlineCode",{parentName:"p"},"system_program")," is also optional for initialization now but we need it for wager transfer, so it is still required:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// The system program for transferring the wager and initializing the game if needed.\npub system_program: SystemProgram<AI>,\n")),(0,o.kt)("h3",{id:"other_player_profile"},(0,o.kt)("inlineCode",{parentName:"h3"},"other_player_profile")),(0,o.kt)("p",null,"Lastly we have the other player's profile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// If [`Some`] locks other player to a given profile.\npub other_player_profile: Option<ReadOnlyDataAccount<AI, TutorialAccounts, PlayerProfile>>,\n")),(0,o.kt)("p",null,"This lets us fulfill the requirement of allowing the other player to be set to a specific profile. By using ",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"FromAccounts<()>")," implementation we determine if we decode this account by its presence in the list of accounts."),(0,o.kt)("h2",{id:"processor"},"Processor"),(0,o.kt)("p",null,"Next we'll add the instruction processing code. This is going to need to handle a few more things than in ",(0,o.kt)("inlineCode",{parentName:"p"},"create_profile"),": data routing, wager transfer, and other player profile locking."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'/// Data for [`CreateGame`]\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]\npub struct CreateGameData {\n/// Which position the creator wants to play in.\npub creator_player: Player,\n/// The bump for the game signer.\npub signer_bump: u8,\n/// The wager each player will place. Winner gets double this amount.\npub wager: u64,\n/// The length of time each player gets to play their turn. Starts once other player joins.\npub turn_length: UnixTimestamp,\n}\n\n#[cfg(feature = "processor")]\nmod processor {\nuse super::*;\nuse std::iter::empty;\n\n    impl<\'a, AI> InstructionProcessor<AI, CreateGame> for CreateGame\n    where\n        AI: ToSolanaAccountInfo<\'a>,\n    {\n        type FromAccountsData = CreateGameData;\n        type ValidateData = ();\n        type InstructionData = CreateGameData;\n\n        fn data_to_instruction_arg(\n            data: <CreateGame as Instruction<AI>>::Data,\n        ) -> CruiserResult<(\n            Self::FromAccountsData,\n            Self::ValidateData,\n            Self::InstructionData,\n        )> {\n            assert!(data.wager.checked_mul(2).is_some(), "wager too large");\n            Ok((data.clone(), (), data))\n        }\n\n        fn process(\n            _program_id: &Pubkey,\n            data: Self::InstructionData,\n            accounts: &mut <CreateGame as Instruction<AI>>::Accounts,\n        ) -> CruiserResult<<CreateGame as Instruction<AI>>::ReturnType> {\n            // Transfer the wager from the wager_funder to the game signer.\n            accounts.system_program.transfer(\n                CPIChecked,\n                &accounts.wager_funder,\n                accounts.game_signer.info(),\n                data.wager,\n                empty(),\n            )?;\n\n            // Set the other player\'s profile if locked game.\n            if let Some(other_player_profile) = &accounts.other_player_profile {\n                *match data.creator_player {\n                    Player::One => &mut accounts.game.player2,\n                    Player::Two => &mut accounts.game.player1,\n                } = *other_player_profile.info().key()\n            }\n\n            Ok(())\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Data routing is handled in the ",(0,o.kt)("inlineCode",{parentName:"p"},"data_to_instruction_arg")," method. This method takes the data from the instruction and turns it into a tuple of three values: the data that will be used to create the instruction, the data that will be used to validate the instruction, and the data that will be used to process the instruction. In our case the data will be passed to both the ",(0,o.kt)("inlineCode",{parentName:"p"},"ValidateArgument")," implementation and ",(0,o.kt)("inlineCode",{parentName:"p"},"process")," method so we clone it and send it both ways."),(0,o.kt)("p",null,"In our processing we see how easy CPI calls can be. In this case we just call ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," directly on the system program account with the proper arguments. We use ",(0,o.kt)("inlineCode",{parentName:"p"},"empty")," as the seeds because none of the required signers are PDAs. Then we see normal rust code to set the other player's profile if it was passed in."),(0,o.kt)("h2",{id:"add-to-instructionlist"},"Add to ",(0,o.kt)("inlineCode",{parentName:"h2"},"InstructionList")),(0,o.kt)("p",null,"Next we need to register our instruction with our instruction list. To do this we'll add the following to the list in ",(0,o.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, InstructionList, Copy, Clone)]\n#[instruction_list(\n    account_list = TutorialAccounts,\n    account_info = [<'a, AI> AI where AI: ToSolanaAccountInfo<'a>],\n    discriminant_type = u8,\n)]\npub enum TutorialInstructions {\n    /// Creates a new player profile.\n    #[instruction(instruction_type = instructions::CreateProfile)]\n    CreateProfile,\n    /// Create a new game.\n    #[instruction(instruction_type = instructions::CreateGame)]\n    CreateGame,\n}\n")),(0,o.kt)("h2",{id:"cpi"},"CPI"),(0,o.kt)("p",null,"Next we'll add in the cpi functions for this instruction. We need to handle four different cases: init and zeroed for both locked other player and not. For this we will create new methods for each but there are smarter ways to do this. We also use static size account lists which are faster than dynamic:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"cpi\")]\npub use cpi::*;\n/// CPI for [`CreateGame`]\n#[cfg(feature = \"cpi\")]\nmod cpi {\n    use super::*;\n    use crate::TutorialInstructions;\n\n    /// Creates a new game.\n    #[derive(Debug)]\n    pub struct CreateGameCPI<'a, AI, const N: usize> {\n        accounts: [MaybeOwned<'a, AI>; N],\n        data: Vec<u8>,\n    }\n    impl<'a, AI> CreateGameCPI<'a, AI, 6> {\n        /// Creates a new game from a zeroed account.\n        pub fn new_zeroed(\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            player_profile: impl Into<MaybeOwned<'a, AI>>,\n            game: impl Into<MaybeOwned<'a, AI>>,\n            game_signer: impl Into<MaybeOwned<'a, AI>>,\n            wager_funder: impl Into<MaybeOwned<'a, AI>>,\n            system_program: impl Into<MaybeOwned<'a, AI>>,\n            create_game_data: &CreateGameData,\n        ) -> CruiserResult<Self> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<CreateGame>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            create_game_data.serialize(&mut data)?;\n            Ok(Self {\n                accounts: [\n                    authority.into(),\n                    player_profile.into(),\n                    game.into(),\n                    game_signer.into(),\n                    wager_funder.into(),\n                    system_program.into(),\n                ],\n                data,\n            })\n        }\n    }\n    impl<'a, AI> CreateGameCPI<'a, AI, 7> {\n        /// Creates a new game\n        #[allow(clippy::too_many_arguments)]\n        pub fn new(\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            player_profile: impl Into<MaybeOwned<'a, AI>>,\n            game: impl Into<MaybeOwned<'a, AI>>,\n            game_signer: impl Into<MaybeOwned<'a, AI>>,\n            wager_funder: impl Into<MaybeOwned<'a, AI>>,\n            system_program: impl Into<MaybeOwned<'a, AI>>,\n            funder: impl Into<MaybeOwned<'a, AI>>,\n            create_game_data: &CreateGameData,\n        ) -> CruiserResult<Self> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<CreateGame>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            create_game_data.serialize(&mut data)?;\n            Ok(Self {\n                accounts: [\n                    authority.into(),\n                    player_profile.into(),\n                    game.into(),\n                    game_signer.into(),\n                    wager_funder.into(),\n                    system_program.into(),\n                    funder.into(),\n                ],\n                data,\n            })\n        }\n\n        /// Creates a new game from a zeroed account and locked other player.\n        #[allow(clippy::too_many_arguments)]\n        pub fn new_zeroed_with_locked_player(\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            player_profile: impl Into<MaybeOwned<'a, AI>>,\n            game: impl Into<MaybeOwned<'a, AI>>,\n            game_signer: impl Into<MaybeOwned<'a, AI>>,\n            wager_funder: impl Into<MaybeOwned<'a, AI>>,\n            system_program: impl Into<MaybeOwned<'a, AI>>,\n            other_player_profile: impl Into<MaybeOwned<'a, AI>>,\n            create_game_data: &CreateGameData,\n        ) -> CruiserResult<Self> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<CreateGame>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            create_game_data.serialize(&mut data)?;\n            Ok(Self {\n                accounts: [\n                    authority.into(),\n                    player_profile.into(),\n                    game.into(),\n                    game_signer.into(),\n                    wager_funder.into(),\n                    system_program.into(),\n                    other_player_profile.into(),\n                ],\n                data,\n            })\n        }\n    }\n    impl<'a, AI> CreateGameCPI<'a, AI, 8> {\n        /// Creates a new game with a locked other player.\n        #[allow(clippy::too_many_arguments)]\n        pub fn new_with_locked_player(\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            player_profile: impl Into<MaybeOwned<'a, AI>>,\n            game: impl Into<MaybeOwned<'a, AI>>,\n            game_signer: impl Into<MaybeOwned<'a, AI>>,\n            wager_funder: impl Into<MaybeOwned<'a, AI>>,\n            system_program: impl Into<MaybeOwned<'a, AI>>,\n            funder: impl Into<MaybeOwned<'a, AI>>,\n            other_player_profile: impl Into<MaybeOwned<'a, AI>>,\n            create_game_data: &CreateGameData,\n        ) -> CruiserResult<Self> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<CreateGame>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            create_game_data.serialize(&mut data)?;\n            Ok(Self {\n                accounts: [\n                    authority.into(),\n                    player_profile.into(),\n                    game.into(),\n                    game_signer.into(),\n                    wager_funder.into(),\n                    system_program.into(),\n                    funder.into(),\n                    other_player_profile.into(),\n                ],\n                data,\n            })\n        }\n    }\n\n    impl<'a, AI> CPIClientStatic<'a, 7> for CreateGameCPI<'a, AI, 6>\n    where\n        AI: ToSolanaAccountMeta,\n    {\n        type InstructionList = TutorialInstructions;\n        type Instruction = CreateGame;\n        type AccountInfo = AI;\n\n        fn instruction(\n            self,\n            program_account: impl Into<MaybeOwned<'a, Self::AccountInfo>>,\n        ) -> InstructionAndAccounts<[MaybeOwned<'a, Self::AccountInfo>; 7]> {\n            let program_account = program_account.into();\n            let instruction = SolanaInstruction {\n                program_id: *program_account.meta_key(),\n                accounts: self\n                    .accounts\n                    .iter()\n                    .map(MaybeOwned::as_ref)\n                    .map(AI::to_solana_account_meta)\n                    .collect(),\n                data: self.data,\n            };\n            let mut accounts = self.accounts.into_iter();\n            InstructionAndAccounts {\n                instruction,\n                accounts: [\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    program_account,\n                ],\n            }\n        }\n    }\n    impl<'a, AI> CPIClientStatic<'a, 8> for CreateGameCPI<'a, AI, 7>\n    where\n        AI: ToSolanaAccountMeta,\n    {\n        type InstructionList = TutorialInstructions;\n        type Instruction = CreateGame;\n        type AccountInfo = AI;\n\n        fn instruction(\n            self,\n            program_account: impl Into<MaybeOwned<'a, Self::AccountInfo>>,\n        ) -> InstructionAndAccounts<[MaybeOwned<'a, Self::AccountInfo>; 8]> {\n            let program_account = program_account.into();\n            let instruction = SolanaInstruction {\n                program_id: *program_account.meta_key(),\n                accounts: self\n                    .accounts\n                    .iter()\n                    .map(MaybeOwned::as_ref)\n                    .map(AI::to_solana_account_meta)\n                    .collect(),\n                data: self.data,\n            };\n            let mut accounts = self.accounts.into_iter();\n            InstructionAndAccounts {\n                instruction,\n                accounts: [\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    program_account,\n                ],\n            }\n        }\n    }\n    impl<'a, AI> CPIClientStatic<'a, 9> for CreateGameCPI<'a, AI, 8>\n    where\n        AI: ToSolanaAccountMeta,\n    {\n        type InstructionList = TutorialInstructions;\n        type Instruction = CreateGame;\n        type AccountInfo = AI;\n\n        fn instruction(\n            self,\n            program_account: impl Into<MaybeOwned<'a, Self::AccountInfo>>,\n        ) -> InstructionAndAccounts<[MaybeOwned<'a, Self::AccountInfo>; 9]> {\n            let program_account = program_account.into();\n            let instruction = SolanaInstruction {\n                program_id: *program_account.meta_key(),\n                accounts: self\n                    .accounts\n                    .iter()\n                    .map(MaybeOwned::as_ref)\n                    .map(AI::to_solana_account_meta)\n                    .collect(),\n                data: self.data,\n            };\n            let mut accounts = self.accounts.into_iter();\n            InstructionAndAccounts {\n                instruction,\n                accounts: [\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    program_account,\n                ],\n            }\n        }\n    }\n}\n")),(0,o.kt)("h2",{id:"client"},"Client"),(0,o.kt)("p",null,"For the client we will collapse the four methods into 2, where each handles both options for locked other player. We could collapse this further by adding an argument to determine if we should use a zeroed account. We can't dynamically check the chain for this because our instruction may be coming after another that creates the zeroed account."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"client\")]\npub use client::*;\n/// Client for [`CreateGame`]\n#[cfg(feature = \"client\")]\nmod client {\n    use super::*;\n    use std::future::Future;\n\n    /// Data for [`create_game`]\n    #[derive(Clone, Debug)]\n    pub struct CreateGameClientData {\n        /// Which position the creator wants to play in.\n        pub creator_player: Player,\n        /// The wager each player will place. Winner gets double this amount.\n        pub wager: u64,\n        /// The length of time each player gets to play their turn. Starts once other player joins.\n        pub turn_length: UnixTimestamp,\n    }\n    impl CreateGameClientData {\n        /// Turns this into [`CreateGameData`]\n        pub fn into_data(self, signer_bump: u8) -> CreateGameData {\n            CreateGameData {\n                creator_player: self.creator_player,\n                wager: self.wager,\n                turn_length: self.turn_length,\n                signer_bump,\n            }\n        }\n    }\n\n    /// Creates a new game.\n    #[allow(clippy::too_many_arguments)]\n    pub fn create_game<'a>(\n        program_id: Pubkey,\n        authority: impl Into<HashedSigner<'a>>,\n        player_profile: Pubkey,\n        game: impl Into<HashedSigner<'a>>,\n        wager_funder: impl Into<HashedSigner<'a>>,\n        funder: impl Into<HashedSigner<'a>>,\n        other_player_profile: Option<Pubkey>,\n        data: CreateGameClientData,\n    ) -> InstructionSet<'a> {\n        let authority = authority.into();\n        let game = game.into();\n        let wager_funder = wager_funder.into();\n        let funder = funder.into();\n\n        let (game_signer, signer_bump) = GameSignerSeeder {\n            game: game.pubkey(),\n        }\n        .find_address(&program_id);\n\n        match other_player_profile {\n            Some(other_player_profile) => InstructionSet {\n                instructions: vec![\n                    cpi::CreateGameCPI::new_with_locked_player(\n                        SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                        SolanaAccountMeta::new(player_profile, false),\n                        SolanaAccountMeta::new(game.pubkey(), true),\n                        SolanaAccountMeta::new(game_signer, false),\n                        SolanaAccountMeta::new(wager_funder.pubkey(), true),\n                        SolanaAccountMeta::new_readonly(SystemProgram::<()>::KEY, false),\n                        SolanaAccountMeta::new(funder.pubkey(), true),\n                        SolanaAccountMeta::new_readonly(other_player_profile, false),\n                        &data.into_data(signer_bump),\n                    )\n                    .unwrap()\n                    .instruction(SolanaAccountMeta::new_readonly(program_id, false))\n                    .instruction,\n                ],\n                signers: [authority, game, wager_funder, funder]\n                    .into_iter()\n                    .collect(),\n            },\n            None => InstructionSet {\n                instructions: vec![\n                    cpi::CreateGameCPI::new(\n                        SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                        SolanaAccountMeta::new(player_profile, false),\n                        SolanaAccountMeta::new(game.pubkey(), true),\n                        SolanaAccountMeta::new(game_signer, false),\n                        SolanaAccountMeta::new(wager_funder.pubkey(), true),\n                        SolanaAccountMeta::new_readonly(SystemProgram::<()>::KEY, false),\n                        SolanaAccountMeta::new(funder.pubkey(), true),\n                        &data.into_data(signer_bump),\n                    )\n                    .unwrap()\n                    .instruction(SolanaAccountMeta::new_readonly(program_id, false))\n                    .instruction,\n                ],\n                signers: [authority, game, wager_funder, funder]\n                    .into_iter()\n                    .collect(),\n            },\n        }\n    }\n\n    /// Creates a new game from a zeroed account.\n    #[allow(clippy::too_many_arguments)]\n    pub async fn create_game_zeroed<'a, F, E>(\n        program_id: Pubkey,\n        authority: impl Into<HashedSigner<'a>>,\n        player_profile: Pubkey,\n        game: impl Into<HashedSigner<'a>>,\n        wager_funder: impl Into<HashedSigner<'a>>,\n        funder: impl Into<HashedSigner<'a>>,\n        other_player_profile: Option<Pubkey>,\n        data: CreateGameClientData,\n        rent: impl FnOnce(usize) -> F,\n    ) -> Result<InstructionSet<'a>, E>\n    where\n        F: Future<Output = Result<u64, E>>,\n    {\n        let authority = authority.into();\n        let game = game.into();\n        let game_key = game.pubkey();\n        let wager_funder = wager_funder.into();\n        let funder = funder.into();\n\n        let (game_signer, signer_bump) =\n            GameSignerSeeder { game: game_key }.find_address(&program_id);\n\n        let mut out = system_program::create_account(\n            funder,\n            game,\n            rent(Game::ON_CHAIN_SIZE).await?,\n            Game::ON_CHAIN_SIZE as u64,\n            program_id,\n        );\n        out.add_set(match other_player_profile {\n            Some(other_player_profile) => InstructionSet {\n                instructions: vec![\n                    cpi::CreateGameCPI::new_zeroed_with_locked_player(\n                        SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                        SolanaAccountMeta::new(player_profile, false),\n                        SolanaAccountMeta::new(game_key, false),\n                        SolanaAccountMeta::new(game_signer, false),\n                        SolanaAccountMeta::new(wager_funder.pubkey(), true),\n                        SolanaAccountMeta::new_readonly(SystemProgram::<()>::KEY, false),\n                        SolanaAccountMeta::new_readonly(other_player_profile, false),\n                        &data.into_data(signer_bump),\n                    )\n                    .unwrap()\n                    .instruction(SolanaAccountMeta::new_readonly(program_id, false))\n                    .instruction,\n                ],\n                signers: [authority, wager_funder].into_iter().collect(),\n            },\n            None => InstructionSet {\n                instructions: vec![\n                    cpi::CreateGameCPI::new_zeroed(\n                        SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                        SolanaAccountMeta::new(player_profile, false),\n                        SolanaAccountMeta::new(game_key, false),\n                        SolanaAccountMeta::new(game_signer, false),\n                        SolanaAccountMeta::new(wager_funder.pubkey(), true),\n                        SolanaAccountMeta::new_readonly(SystemProgram::<()>::KEY, false),\n                        &data.into_data(signer_bump),\n                    )\n                    .unwrap()\n                    .instruction(SolanaAccountMeta::new_readonly(program_id, false))\n                    .instruction,\n                ],\n                signers: [authority, wager_funder].into_iter().collect(),\n            },\n        });\n        Ok(out)\n    }\n}\n")),(0,o.kt)("h2",{id:"tests"},"Tests"),(0,o.kt)("p",null,"Finally, we can add tests for our function. First we need to add it to ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/instructions/mod.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod create_game;\n")),(0,o.kt)("p",null,"Then we'll add the test to ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/instructions/create_game.rs"),". For this tutorial we will only test the init with no other player path but good practice would be to test all paths, as well as missing signers and other attacks."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::instructions::setup_validator;\nuse cruiser::prelude::*;\nuse cruiser_tutorial::accounts::{Game, Player};\nuse cruiser_tutorial::instructions::{create_game, create_profile, CreateGameClientData};\nuse cruiser_tutorial::TutorialAccounts;\nuse std::error::Error;\nuse std::time::Duration;\n\n#[tokio::test]\nasync fn create_game_test() -> Result<(), Box<dyn Error>> {\n    let guard = setup_validator().await;\n\n    let rpc = guard.rpc();\n    let funder = Keypair::new();\n\n    // Airdrop SOL to the funder\n    let blockhash = rpc.get_latest_blockhash().await?;\n    let sig = rpc\n        .request_airdrop_with_blockhash(&funder.pubkey(), LAMPORTS_PER_SOL * 10, &blockhash)\n        .await?;\n    rpc.confirm_transaction_with_spinner(&sig, &blockhash, CommitmentConfig::confirmed())\n        .await?;\n\n    // Create random authority and profile\n    let authority = Keypair::new();\n    let profile = Keypair::new();\n    let game = Keypair::new();\n\n    // Send transaction\n    let (sig, result) = TransactionBuilder::new(&funder)\n        .signed_instructions(create_profile(\n            guard.program_id(),\n            &authority,\n            &profile,\n            &funder,\n        ))\n        .signed_instructions(create_game(\n            guard.program_id(),\n            &authority,\n            profile.pubkey(),\n            &game,\n            &funder,\n            &funder,\n            None,\n            CreateGameClientData {\n                creator_player: Player::One,\n                wager: LAMPORTS_PER_SOL,\n                turn_length: 60 * 60 * 24, // 1 day\n            },\n        ))\n        .send_and_confirm_transaction(\n            rpc,\n            RpcSendTransactionConfig {\n                skip_preflight: false,\n                preflight_commitment: Some(CommitmentLevel::Confirmed),\n                encoding: None,\n                max_retries: None,\n            },\n            CommitmentConfig::confirmed(),\n            Duration::from_millis(500),\n        )\n        .await?;\n\n    // Check result\n    match result {\n        ConfirmationResult::Success => {}\n        ConfirmationResult::Failure(error) => return Err(error.into()),\n        ConfirmationResult::Dropped => return Err("Transaction dropped".into()),\n    }\n\n    // Print logs for debugging\n    println!(\n        "Logs: {:#?}",\n        rpc.get_transaction_with_config(\n            &sig,\n            RpcTransactionConfig {\n                encoding: None,\n                commitment: Some(CommitmentConfig::confirmed()),\n                max_supported_transaction_version: None\n            }\n        )\n        .await?\n        .transaction\n        .meta\n        .unwrap()\n        .log_messages\n    );\n\n    // Check account data is what we expect\n    let account = rpc\n        .get_account_with_commitment(&game.pubkey(), CommitmentConfig::confirmed())\n        .await?\n        .value\n        .unwrap_or_else(|| {\n            panic!("Account not found");\n        });\n    let mut data = account.data.as_slice();\n    let discriminant =\n        <TutorialAccounts as AccountList>::DiscriminantCompressed::deserialize(&mut data)?;\n    assert_eq!(\n        discriminant,\n        <TutorialAccounts as AccountListItem<Game>>::compressed_discriminant()\n    );\n    let board = Game::deserialize(&mut data)?;\n    assert_eq!(\n        board,\n        Game::new(\n            &profile.pubkey(),\n            Player::One,\n            board.signer_bump,\n            LAMPORTS_PER_SOL,\n            60 * 60 * 24\n        )\n    );\n\n    guard.drop_self().await;\n    Ok(())\n}\n')),(0,o.kt)("p",null,"This test should execute without error. To run it you can either run ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client --test all_tests instructions::create_game::create_game_test -- --exact")," to run only this test."))}d.isMDXComponent=!0}}]);