"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[3911],{3905:function(n,e,t){t.d(e,{Zo:function(){return l},kt:function(){return d}});var u=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(n);e&&(u=u.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,u)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function a(n,e){if(null==n)return{};var t,u,r=function(n,e){if(null==n)return{};var t,u,r={},o=Object.keys(n);for(u=0;u<o.length;u++)t=o[u],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(u=0;u<o.length;u++)t=o[u],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var i=u.createContext({}),s=function(n){var e=u.useContext(i),t=e;return n&&(t="function"==typeof n?n(e):c(c({},e),n)),t},l=function(n){var e=s(n.components);return u.createElement(i.Provider,{value:e},n.children)},A={inlineCode:"code",wrapper:function(n){var e=n.children;return u.createElement(u.Fragment,{},e)}},m=u.forwardRef((function(n,e){var t=n.components,r=n.mdxType,o=n.originalType,i=n.parentName,l=a(n,["components","mdxType","originalType","parentName"]),m=s(t),d=r,g=m["".concat(i,".").concat(d)]||m[d]||A[d]||o;return t?u.createElement(g,c(c({ref:e},l),{},{components:t})):u.createElement(g,c({ref:e},l))}));function d(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var o=t.length,c=new Array(o);c[0]=m;var a={};for(var i in e)hasOwnProperty.call(e,i)&&(a[i]=e[i]);a.originalType=n,a.mdxType="string"==typeof n?n:r,c[1]=a;for(var s=2;s<o;s++)c[s]=t[s];return u.createElement.apply(null,c)}return u.createElement.apply(null,t)}m.displayName="MDXCreateElement"},400:function(n,e,t){t.r(e),t.d(e,{assets:function(){return l},contentTitle:function(){return i},default:function(){return d},frontMatter:function(){return a},metadata:function(){return s},toc:function(){return A}});var u=t(3117),r=t(102),o=(t(7294),t(3905)),c=["components"],a={sidebar_position:2},i="Custom Account Arguments",s={unversionedId:"cruiser/advanced-topics/Custom Account Arguments",id:"cruiser/advanced-topics/Custom Account Arguments",title:"Custom Account Arguments",description:"AccountArgument is the main type used to create the lists of accounts cruiser programs use, but we can also create custom types for reuse by our programs or for other programs.",source:"@site/docs/cruiser/advanced-topics/Custom Account Arguments.md",sourceDirName:"cruiser/advanced-topics",slug:"/cruiser/advanced-topics/Custom Account Arguments",permalink:"/docs/cruiser/advanced-topics/Custom Account Arguments",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/advanced-topics/Custom Account Arguments.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Further Topics",permalink:"/docs/cruiser/walkthrough/Further Topics"},next:{title:"Custom Account Infos",permalink:"/docs/cruiser/advanced-topics/Custom Account Infos"}},l={},A=[{value:"Simple Derive",id:"simple-derive",level:2},{value:"Derive With Data",id:"derive-with-data",level:2},{value:"Derive With Multiple Data Options",id:"derive-with-multiple-data-options",level:2},{value:"SingleIndexable and MultiIndexable",id:"singleindexable-and-multiindexable",level:2},{value:"Manual Implementation",id:"manual-implementation",level:2}],m={toc:A};function d(n){var e=n.components,t=(0,r.Z)(n,c);return(0,o.kt)("wrapper",(0,u.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"custom-account-arguments"},"Custom Account Arguments"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"AccountArgument")," is the main type used to create the lists of accounts ",(0,o.kt)("inlineCode",{parentName:"p"},"cruiser")," programs use, but we can also create custom types for reuse by our programs or for other programs. "),(0,o.kt)("h2",{id:"simple-derive"},"Simple Derive"),(0,o.kt)("p",null,"The simplest way to do this is by deriving ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountArgument")," the same way we would for an instruction's accounts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\npub struct CustomAccountArgument<AI> {\n    pub account1: AI,\n    pub account2: AI,\n    pub account3: AI,\n}\n")),(0,o.kt)("p",null,"Then we can use this in other account argument derivations just like cruiser's built in types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\npub struct InstructionAccounts<AI> {\n    pub funder: AI,\n    pub custom: CustomAccountArgument<AI>,\n    pub optional_custom: Option<CustomAccountArgument<AI>>,\n}\n")),(0,o.kt)("h2",{id:"derive-with-data"},"Derive With Data"),(0,o.kt)("p",null,"We can also require data to be passed in and use it like any other type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[validate(data = (account_2_owner: &Pubkey))]\npub struct CustomAccountArgument<AI> {\n    pub account1: AI,\n    #[validate(owner = account_2_owner)]\n    pub account2: AI,\n    pub account3: AI,\n}\n\n#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\npub struct InstructionAccounts<AI> {\n    pub funder: AI,\n    #[validate(data = &SystemProgram::<()>::KEY)]\n    pub custom: CustomAccountArgument<AI>,\n    #[validate(data = IfSomeArg(&SystemProgram::<()>::KEY))]\n    pub optional_custom: Option<CustomAccountArgument<AI>>,\n}\n")),(0,o.kt)("h2",{id:"derive-with-multiple-data-options"},"Derive With Multiple Data Options"),(0,o.kt)("p",null,"If we want there to be multiple paths to build or verify the argument we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," attribute:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[validate(data = (account_2_owner: &Pubkey))] // No ID is a unique id\n// implementations are differentiated by types, id is only for deriving\n#[validate(id = account1, data = (account_1_owner: &Pubkey, _null: ()))]\n// If `validate` attr exists the default `()` impl is not generated.\n// Add an id with no data to get it back.\n#[validate(id = unit)]\npub struct CustomAccountArgument<AI> {\n    #[validate(id = account1, owner = account_1_owner)]\n    pub account1: AI,\n    #[validate(owner = account_2_owner)]\n    pub account2: AI,\n    #[validate(id = unit, owner = &SystemProgram::<()>::KEY)]\n    pub account3: AI,\n}\n\n#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\npub struct InstructionAccounts<AI> {\n    pub funder: AI,\n    #[validate(data = &SystemProgram::<()>::KEY)]\n    pub custom: CustomAccountArgument<AI>,\n    #[validate(data = IfSomeArg(&SystemProgram::<()>::KEY))]\n    pub optional_custom: Option<CustomAccountArgument<AI>>,\n}\n")),(0,o.kt)("h2",{id:"singleindexable-and-multiindexable"},"SingleIndexable and MultiIndexable"),(0,o.kt)("p",null,"If we have a type that it makes sense to be able to operate on a subset of the accounts or on individual accounts we can implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"SingleIndexable")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"MultiIndexable")," traits. These traits are what powers the ",(0,o.kt)("inlineCode",{parentName:"p"},"signer"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"writable"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"owner"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," validation attributes. ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," uses ",(0,o.kt)("inlineCode",{parentName:"p"},"SingleIndexable")," while the rest use ",(0,o.kt)("inlineCode",{parentName:"p"},"MultiIndexable"),". If you implement ",(0,o.kt)("inlineCode",{parentName:"p"},"SingleIndexable<()>")," that means your argument is a wrapper around a single account."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\npub struct CustomAccountArgument<AI> {\n    pub account1: AI,\n    pub account2: AI,\n    pub account3: AI,\n}\n// These are meant for demonstration, it's usually useless to add these.\n#[derive(Copy, Clone, Debug)]\npub enum CustomAccountArgumentSubset {\n    Accounts12,\n    Accounts23,\n    Accounts31,\n}\nimpl CustomAccountArgumentSubset {\n    fn get_subset<AI>(self, argument: &CustomAccountArgument<AI>) -> [&AI; 2] {\n        match self {\n            CustomAccountArgumentSubset::Accounts12 => [&argument.account1, &argument.account2],\n            CustomAccountArgumentSubset::Accounts23 => [&argument.account2, &argument.account3],\n            CustomAccountArgumentSubset::Accounts31 => [&argument.account3, &argument.account1],\n        }\n    }\n}\n#[derive(Copy, Clone, Debug)]\npub enum CustomAccountArgumentIndex {\n    Account1,\n    Account2,\n    Account3,\n}\nimpl CustomAccountArgumentIndex {\n    fn get_index<AI>(self, argument: &CustomAccountArgument<AI>) -> &AI {\n        match self {\n            CustomAccountArgumentIndex::Account1 => &argument.account1,\n            CustomAccountArgumentIndex::Account2 => &argument.account2,\n            CustomAccountArgumentIndex::Account3 => &argument.account3,\n        }\n    }\n}\n\nimpl<AI> CustomAccountArgument<AI> {\n    fn to_iter(&self) -> impl Iterator<Item = &AI> {\n        [&self.account1, &self.account2, &self.account3].into_iter()\n    }\n}\n// `AllAny` allows us to use `signer(all)` and `signer(any)` in the `validate` attr.\n// `not_all` and `not_any` are also available.\nimpl<AI> MultiIndexable<AllAny> for CustomAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n{\n    fn index_is_signer(&self, indexer: AllAny) -> CruiserResult<bool> {\n        indexer.run_func(self.to_iter(), |account| account.index_is_signer(()))\n    }\n\n    fn index_is_writable(&self, indexer: AllAny) -> CruiserResult<bool> {\n        indexer.run_func(self.to_iter(), |account| account.index_is_writable(()))\n    }\n\n    fn index_is_owner(&self, owner: &Pubkey, indexer: AllAny) -> CruiserResult<bool> {\n        indexer.run_func(self.to_iter(), |account| account.index_is_owner(owner, ()))\n    }\n}\nimpl<AI> MultiIndexable<CustomAccountArgumentSubset> for CustomAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n{\n    fn index_is_signer(&self, indexer: CustomAccountArgumentSubset) -> CruiserResult<bool> {\n        indexer\n            .get_subset(self)\n            .into_iter()\n            .map(|account| account.index_is_signer(()))\n            .fold(Ok(true), |acc, res| match acc {\n                Ok(acc) => Ok(acc && res?),\n                Err(e) => Err(e),\n            })\n    }\n\n    fn index_is_writable(&self, indexer: CustomAccountArgumentSubset) -> CruiserResult<bool> {\n        indexer\n            .get_subset(self)\n            .into_iter()\n            .map(|account| account.index_is_writable(()))\n            .fold(Ok(true), |acc, res| match acc {\n                Ok(acc) => Ok(acc && res?),\n                Err(e) => Err(e),\n            })\n    }\n\n    fn index_is_owner(\n        &self,\n        owner: &Pubkey,\n        indexer: CustomAccountArgumentSubset,\n    ) -> CruiserResult<bool> {\n        indexer\n            .get_subset(self)\n            .into_iter()\n            .map(|account| account.index_is_owner(owner, ()))\n            .fold(Ok(true), |acc, res| match acc {\n                Ok(acc) => Ok(acc && res?),\n                Err(e) => Err(e),\n            })\n    }\n}\n// We need `MultiIndexable<$ty>` to implement `SingleIndexable<$ty>`.\nimpl<AI> MultiIndexable<CustomAccountArgumentIndex> for CustomAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n{\n    fn index_is_signer(&self, indexer: CustomAccountArgumentIndex) -> CruiserResult<bool> {\n        indexer.get_index(self).index_is_signer(())\n    }\n\n    fn index_is_writable(&self, indexer: CustomAccountArgumentIndex) -> CruiserResult<bool> {\n        indexer.get_index(self).index_is_writable(())\n    }\n\n    fn index_is_owner(\n        &self,\n        owner: &Pubkey,\n        indexer: CustomAccountArgumentIndex,\n    ) -> CruiserResult<bool> {\n        indexer.get_index(self).index_is_owner(owner, ())\n    }\n}\nimpl<AI> SingleIndexable<CustomAccountArgumentIndex> for CustomAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n{\n    fn index_info(\n        &self,\n        indexer: CustomAccountArgumentIndex,\n    ) -> CruiserResult<&Self::AccountInfo> {\n        indexer.get_index(self).index_info(())\n    }\n}\n")),(0,o.kt)("p",null,"If we want to use it we can do so like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n    #[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n    pub struct InstructionAccounts<AI> {\n        pub funder: AI,\n        #[validate(\n            key(CustomAccountArgumentIndex::Account1) = &SystemProgram::<()>::KEY,\n            writable(any),\n        )]\n        pub custom: CustomAccountArgument<AI>,\n        #[validate(signer(IfSomeArg(CustomAccountArgumentSubset::Accounts31)))]\n        pub optional_custom: Option<CustomAccountArgument<AI>>,\n    }\n")),(0,o.kt)("h2",{id:"manual-implementation"},"Manual Implementation"),(0,o.kt)("p",null,"If we want some custom logic that may not be possible to express with the ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountArgument")," derive, then we manually implement the traits. For this example we will have a set of accounts that all need to point to each other in a ring."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountList)]\npub enum RingAccounts {\n    RingAccount(RingAccount),\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct RingAccount {\n    next: Pubkey,\n}\n\npub struct RingAccountArgument<AI> {\n    accounts: Vec<ReadOnlyDataAccount<AI, RingAccounts, RingAccount>>,\n}\n\n// For `AccountArgument` and `ValidateArgument` we are delegating to `Vec`'s implementation.\n// Since we are doing that we can also use the derive for only those traits.\n#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo], no_from)]\n#[validate(\n    no_single_tupple,\n    data = (arg: Arg),\n    generics = [<Arg> where Vec<ReadOnlyDataAccount<AI, RingAccounts, RingAccount>>: ValidateArgument<Arg>],\n)]\npub struct RingAccountArgument2<AI> {\n    #[validate(data = arg)]\n    accounts: Vec<ReadOnlyDataAccount<AI, RingAccounts, RingAccount>>,\n}\n\n// Only needed for `RingAccountArgument`\nimpl<AI> AccountArgument for RingAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n{\n    type AccountInfo = AI;\n\n    fn write_back(self, program_id: &Pubkey) -> CruiserResult<()> {\n        // Delegate to `Vec`'s implementation\n        self.accounts.write_back(program_id)\n    }\n\n    fn add_keys(&self, add: impl FnMut(Pubkey) -> CruiserResult<()>) -> CruiserResult<()> {\n        // Delegate to `Vec`'s implementation\n        self.accounts.add_keys(add)\n    }\n}\n\n// Needed for both `RingAccountArgument` and `RingAccountArgument2`\nimpl<AI> FromAccounts for RingAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n{\n    fn from_accounts(\n        program_id: &Pubkey,\n        infos: &mut impl AccountInfoIterator<Item = Self::AccountInfo>,\n        _arg: (),\n    ) -> CruiserResult<Self> {\n        let mut out = Vec::new();\n        let first: ReadOnlyDataAccount<_, _, RingAccount> =\n            FromAccounts::from_accounts(program_id, infos, ())?;\n        let first_key = *first.info().key();\n        out.push(first);\n        let mut next_key = &out[0].next;\n\n        loop {\n            let next = ReadOnlyDataAccount::from_accounts(program_id, infos, ())?;\n            assert_is_key(&next, next_key, ())?;\n            out.push(next);\n            next_key = &out[out.len() - 1].next;\n            if next_key == &first_key {\n                break;\n            }\n        }\n\n        Ok(Self { accounts: out })\n    }\n\n    fn accounts_usage_hint(_arg: &()) -> (usize, Option<usize>) {\n        (2, None)\n    }\n}\n\n// Only needed for `RingAccountArgument`\nimpl<AI, Arg> ValidateArgument<Arg> for RingAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n    Vec<ReadOnlyDataAccount<AI, RingAccounts, RingAccount>>: ValidateArgument<Arg>,\n{\n    fn validate(&mut self, program_id: &Pubkey, arg: Arg) -> CruiserResult<()> {\n        // Delegate to `Vec`'s implementation\n        self.accounts.validate(program_id, arg)\n    }\n}\n\nimpl<AI, Arg> MultiIndexable<Arg> for RingAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n    Vec<ReadOnlyDataAccount<AI, RingAccounts, RingAccount>>: MultiIndexable<Arg>,\n{\n    fn index_is_signer(&self, indexer: Arg) -> CruiserResult<bool> {\n        self.accounts.index_is_signer(indexer)\n    }\n\n    fn index_is_writable(&self, indexer: Arg) -> CruiserResult<bool> {\n        self.accounts.index_is_writable(indexer)\n    }\n\n    fn index_is_owner(&self, owner: &Pubkey, indexer: Arg) -> CruiserResult<bool> {\n        self.accounts.index_is_owner(owner, indexer)\n    }\n}\nimpl<AI, Arg> SingleIndexable<Arg> for RingAccountArgument<AI>\nwhere\n    AI: AccountInfo,\n    Vec<ReadOnlyDataAccount<AI, RingAccounts, RingAccount>>:\n        SingleIndexable<Arg, AccountInfo = Self::AccountInfo>,\n{\n    fn index_info(&self, indexer: Arg) -> CruiserResult<&Self::AccountInfo> {\n        self.accounts.index_info(indexer)\n    }\n}\n")))}d.isMDXComponent=!0}}]);