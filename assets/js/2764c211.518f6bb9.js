"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[5584],{3905:function(n,e,t){t.d(e,{Zo:function(){return _},kt:function(){return m}});var r=t(7294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function c(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var s=r.createContext({}),u=function(n){var e=r.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},_=function(n){var e=u(n.components);return r.createElement(s.Provider,{value:e},n.children)},l={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},p=r.forwardRef((function(n,e){var t=n.components,o=n.mdxType,a=n.originalType,s=n.parentName,_=c(n,["components","mdxType","originalType","parentName"]),p=u(t),m=o,k=p["".concat(s,".").concat(m)]||p[m]||l[m]||a;return t?r.createElement(k,i(i({ref:e},_),{},{components:t})):r.createElement(k,i({ref:e},_))}));function m(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var a=t.length,i=new Array(a);i[0]=p;var c={};for(var s in e)hasOwnProperty.call(e,s)&&(c[s]=e[s]);c.originalType=n,c.mdxType="string"==typeof n?n:o,i[1]=c;for(var u=2;u<a;u++)i[u]=t[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7666:function(n,e,t){t.r(e),t.d(e,{assets:function(){return _},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return l}});var r=t(3117),o=t(102),a=(t(7294),t(3905)),i=["components"],c={},s="Sample Escrow Program",u={unversionedId:"cruiser/escrow-example/Escrow Example",id:"cruiser/escrow-example/Escrow Example",title:"Sample Escrow Program",description:"In this example of Cruiser's functionality we will walk through an example escrow program. This is a recreation of the PaulX escrow tutorial and all the code for this project can be found here: Cruiser -> Escrow",source:"@site/docs/cruiser/escrow-example/Escrow Example.md",sourceDirName:"cruiser/escrow-example",slug:"/cruiser/escrow-example/Escrow Example",permalink:"/docs/cruiser/escrow-example/Escrow Example",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/escrow-example/Escrow Example.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IntelliJ File Templates",permalink:"/docs/cruiser/reference-material/intellij_file_templates"},next:{title:"Cryptid",permalink:"/docs/cryptid/"}},_={},l=[{value:"What is an Escrow program?",id:"what-is-an-escrow-program",level:2},{value:"Comparison w/ Vanilla Solana",id:"comparison-w-vanilla-solana",level:2}],p={toc:l};function m(n){var e=n.components,t=(0,o.Z)(n,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"sample-escrow-program"},"Sample Escrow Program"),(0,a.kt)("p",null,"In this example of Cruiser's functionality we will walk through an example escrow program. This is a recreation of the ",(0,a.kt)("a",{parentName:"p",href:"https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/"},"PaulX escrow tutorial")," and all the code for this project can be found here: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/identity-com/cruiser/tree/master/escrow_example"},"Cruiser -> Escrow")),(0,a.kt)("h2",{id:"what-is-an-escrow-program"},"What is an Escrow program?"),(0,a.kt)("p",null,"Escrow is used in a variety of situations, but most commonly in financial transactions where the two parties performing the transaction want a trusted third party to hold the agreed-upon money until the terms of the transaction are fulfilled. This is to prevent one party from cheating the other out of either money, goods, or services."),(0,a.kt)("p",null,"Let's look at an example of this put together with the Cruiser framework."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// This is the list of escrow instructions\n\n#[derive(InstructionList, Copy, Clone)]\n#[instruction_list(account_list = EscrowAccounts, account_info = [<'a, AI> AI where AI: cruiser::ToSolanaAccountInfo<'a>])]\n\npub enum EscrowInstructions {\n    #[instruction(instruction_type = instructions::init_escrow::InitEscrow)]\n    InitEscrow,\n    #[instruction(instruction_type = instructions::exchange::Exchange)]\n    Exchange,\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// The list of escrow accounts\n\n#[derive(AccountList)]\npub enum EscrowAccounts {\n    EscrowAccount(EscrowAccount),\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// This is what an escrow account looks like using standard Borsh serialization\n\n#[derive(BorshSerialize, BorshDeserialize, Default)]\npub struct EscrowAccount {\n    pub initializer: Pubkey,\n    pub temp_token_account: Pubkey,\n    pub initializer_token_to_receive: Pubkey,\n    pub expected_amount: u64,\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// A helpful trait that keeps track of account size on chain\n\nimpl const OnChainSize for EscrowAccount {\n    const ON_CHAIN_SIZE: usize = Pubkey::ON_CHAIN_SIZE * 3 + u64::ON_CHAIN_SIZE;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// This is type-safe PDA seeding that prevents you from mixing up seeds for PDAs\n\n#[derive(Debug)]\nstruct EscrowPDASeeder;\n\nimpl PDASeeder for EscrowPDASeeder {\n    fn seeds<'a>(&'a self) -> Box<dyn Iterator<Item = &'a dyn PDASeed> + 'a> {\n        Box::new([&\"escrow\" as &dyn PDASeed].into_iter())\n    }\n}\n")),(0,a.kt)("h2",{id:"comparison-w-vanilla-solana"},"Comparison w/ Vanilla Solana"),(0,a.kt)("p",null,"That's it! We're done with the escrow program! Let's take a quick look at the same program built with vanilla Solana so you can see the difference. The first thing we'll look at in terms of difference is the Escrow Instruction implementation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum EscrowInstruction {\n    InitEscrow {\n        /// The amount party A expects to receive of token Y\n        amount: u64,\n    },\n    Exchange {\n        /// the amount the taker expects to be paid in the other token, as a u64 because that's the max possible supply of a token\n        amount: u64,\n    },\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"The following is the vanilla way of implementing the Escrow Instruction, as opposed to using Cruiser, where you can just bring the instruction into scope"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"impl EscrowInstruction {\n    /// Unpacks a byte buffer into a [EscrowInstruction](enum.EscrowInstruction.html).\n    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let (tag, rest) = input.split_first().ok_or(InvalidInstruction)?;\n\n        Ok(match tag {\n            0 => Self::InitEscrow {\n                amount: Self::unpack_amount(rest)?,\n            },\n            1 => Self::Exchange {\n                amount: Self::unpack_amount(rest)?,\n            },\n            _ => return Err(InvalidInstruction.into()),\n        })\n    }\n\n    fn unpack_amount(input: &[u8]) -> Result<u64, ProgramError> {\n        let amount = input\n            .get(..8)\n            .and_then(|slice| slice.try_into().ok())\n            .map(u64::from_le_bytes)\n            .ok_or(InvalidInstruction)?;\n        Ok(amount)\n    }\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"That was a lot in comparison, but we're just getting started... Let's next take a look at the code required with vanilla Solana to tell what an Escrow account is"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Escrow {\n    pub is_initialized: bool,\n    pub initializer_pubkey: Pubkey,\n    pub temp_token_account_pubkey: Pubkey,\n    pub initializer_token_to_receive_account_pubkey: Pubkey,\n    pub expected_amount: u64,\n}\n\nimpl Sealed for Escrow {}\n\nimpl IsInitialized for Escrow {\n    fn is_initialized(&self) -> bool {\n        self.is_initialized\n    }\n}\n\nimpl Pack for Escrow {\n    const LEN: usize = 105;\n    fn unpack_from_slice(src: &[u8]) -> Result<Self, ProgramError> {\n        let src = array_ref![src, 0, Escrow::LEN];\n        let (\n            is_initialized,\n            initializer_pubkey,\n            temp_token_account_pubkey,\n            initializer_token_to_receive_account_pubkey,\n            expected_amount,\n        ) = array_refs![src, 1, 32, 32, 32, 8];\n        let is_initialized = match is_initialized {\n            [0] => false,\n            [1] => true,\n            _ => return Err(ProgramError::InvalidAccountData),\n        };\n\n        Ok(Escrow {\n            is_initialized,\n            initializer_pubkey: Pubkey::new_from_array(*initializer_pubkey),\n            temp_token_account_pubkey: Pubkey::new_from_array(*temp_token_account_pubkey),\n            initializer_token_to_receive_account_pubkey: Pubkey::new_from_array(\n                *initializer_token_to_receive_account_pubkey,\n            ),\n            expected_amount: u64::from_le_bytes(*expected_amount),\n        })\n    }\n\n    fn pack_into_slice(&self, dst: &mut [u8]) {\n        let dst = array_mut_ref![dst, 0, Escrow::LEN];\n        let (\n            is_initialized_dst,\n            initializer_pubkey_dst,\n            temp_token_account_pubkey_dst,\n            initializer_token_to_receive_account_pubkey_dst,\n            expected_amount_dst,\n        ) = mut_array_refs![dst, 1, 32, 32, 32, 8];\n\n        let Escrow {\n            is_initialized,\n            initializer_pubkey,\n            temp_token_account_pubkey,\n            initializer_token_to_receive_account_pubkey,\n            expected_amount,\n        } = self;\n\n        is_initialized_dst[0] = *is_initialized as u8;\n        initializer_pubkey_dst.copy_from_slice(initializer_pubkey.as_ref());\n        temp_token_account_pubkey_dst.copy_from_slice(temp_token_account_pubkey.as_ref());\n        initializer_token_to_receive_account_pubkey_dst\n            .copy_from_slice(initializer_token_to_receive_account_pubkey.as_ref());\n        *expected_amount_dst = expected_amount.to_le_bytes();\n    }\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"And finally, let's see what it takes to implement the actual instructions for how an escrow transaction works"))),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"In Cruiser, the way to do this is as follows.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum EscrowInstructions {\n    #[instruction(instruction_type = instructions::init_escrow::InitEscrow)]\n    InitEscrow,\n    #[instruction(instruction_type = instructions::exchange::Exchange)]\n    Exchange,\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"The following, however, is the vanilla method to implement the escrow initialization and exchange instructions"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct Processor;\nimpl Processor {\n    pub fn process(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        let instruction = EscrowInstruction::unpack(instruction_data)?;\n\n        match instruction {\n            EscrowInstruction::InitEscrow { amount } => {\n                msg!("Instruction: InitEscrow");\n                Self::process_init_escrow(accounts, amount, program_id)\n            }\n            EscrowInstruction::Exchange { amount } => {\n                msg!("Instruction: Exchange");\n                Self::process_exchange(accounts, amount, program_id)\n            }\n        }\n    }\n\n    fn process_init_escrow(\n        accounts: &[AccountInfo],\n        amount: u64,\n        program_id: &Pubkey,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let initializer = next_account_info(account_info_iter)?;\n\n        if !initializer.is_signer {\n            return Err(ProgramError::MissingRequiredSignature);\n        }\n\n        let temp_token_account = next_account_info(account_info_iter)?;\n\n        let token_to_receive_account = next_account_info(account_info_iter)?;\n        if *token_to_receive_account.owner != spl_token::id() {\n            return Err(ProgramError::IncorrectProgramId);\n        }\n\n        let escrow_account = next_account_info(account_info_iter)?;\n        let rent = &Rent::from_account_info(next_account_info(account_info_iter)?)?;\n\n        if !rent.is_exempt(escrow_account.lamports(), escrow_account.data_len()) {\n            return Err(EscrowError::NotRentExempt.into());\n        }\n\n        let mut escrow_info = Escrow::unpack_unchecked(&escrow_account.try_borrow_data()?)?;\n        if escrow_info.is_initialized() {\n            return Err(ProgramError::AccountAlreadyInitialized);\n        }\n\n        escrow_info.is_initialized = true;\n        escrow_info.initializer_pubkey = *initializer.key;\n        escrow_info.temp_token_account_pubkey = *temp_token_account.key;\n        escrow_info.initializer_token_to_receive_account_pubkey = *token_to_receive_account.key;\n        escrow_info.expected_amount = amount;\n\n        Escrow::pack(escrow_info, &mut escrow_account.try_borrow_mut_data()?)?;\n        let (pda, _nonce) = Pubkey::find_program_address(&[b"escrow"], program_id);\n\n        let token_program = next_account_info(account_info_iter)?;\n        let owner_change_ix = spl_token::instruction::set_authority(\n            token_program.key,\n            temp_token_account.key,\n            Some(&pda),\n            spl_token::instruction::AuthorityType::AccountOwner,\n            initializer.key,\n            &[&initializer.key],\n        )?;\n\n        msg!("Calling the token program to transfer token account ownership...");\n        invoke(\n            &owner_change_ix,\n            &[\n                temp_token_account.clone(),\n                initializer.clone(),\n                token_program.clone(),\n            ],\n        )?;\n\n        Ok(())\n    }\n\n    fn process_exchange(\n        accounts: &[AccountInfo],\n        amount_expected_by_taker: u64,\n        program_id: &Pubkey,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let taker = next_account_info(account_info_iter)?;\n\n        if !taker.is_signer {\n            return Err(ProgramError::MissingRequiredSignature);\n        }\n\n        let takers_sending_token_account = next_account_info(account_info_iter)?;\n\n        let takers_token_to_receive_account = next_account_info(account_info_iter)?;\n\n        let pdas_temp_token_account = next_account_info(account_info_iter)?;\n        let pdas_temp_token_account_info =\n            TokenAccount::unpack(&pdas_temp_token_account.try_borrow_data()?)?;\n        let (pda, nonce) = Pubkey::find_program_address(&[b"escrow"], program_id);\n\n        if amount_expected_by_taker != pdas_temp_token_account_info.amount {\n            return Err(EscrowError::ExpectedAmountMismatch.into());\n        }\n\n        let initializers_main_account = next_account_info(account_info_iter)?;\n        let initializers_token_to_receive_account = next_account_info(account_info_iter)?;\n        let escrow_account = next_account_info(account_info_iter)?;\n\n        let escrow_info = Escrow::unpack(&escrow_account.try_borrow_data()?)?;\n\n        if escrow_info.temp_token_account_pubkey != *pdas_temp_token_account.key {\n            return Err(ProgramError::InvalidAccountData);\n        }\n\n        if escrow_info.initializer_pubkey != *initializers_main_account.key {\n            return Err(ProgramError::InvalidAccountData);\n        }\n\n        if escrow_info.initializer_token_to_receive_account_pubkey\n            != *initializers_token_to_receive_account.key\n        {\n            return Err(ProgramError::InvalidAccountData);\n        }\n\n        let token_program = next_account_info(account_info_iter)?;\n\n        let transfer_to_initializer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            takers_sending_token_account.key,\n            initializers_token_to_receive_account.key,\n            taker.key,\n            &[&taker.key],\n            escrow_info.expected_amount,\n        )?;\n        msg!("Calling the token program to transfer tokens to the escrow\'s initializer...");\n        invoke(\n            &transfer_to_initializer_ix,\n            &[\n                takers_sending_token_account.clone(),\n                initializers_token_to_receive_account.clone(),\n                taker.clone(),\n                token_program.clone(),\n            ],\n        )?;\n\n        let pda_account = next_account_info(account_info_iter)?;\n\n        let transfer_to_taker_ix = spl_token::instruction::transfer(\n            token_program.key,\n            pdas_temp_token_account.key,\n            takers_token_to_receive_account.key,\n            &pda,\n            &[&pda],\n            pdas_temp_token_account_info.amount,\n        )?;\n        msg!("Calling the token program to transfer tokens to the taker...");\n        invoke_signed(\n            &transfer_to_taker_ix,\n            &[\n                pdas_temp_token_account.clone(),\n                takers_token_to_receive_account.clone(),\n                pda_account.clone(),\n                token_program.clone(),\n            ],\n            &[&[&b"escrow"[..], &[nonce]]],\n        )?;\n\n        let close_pdas_temp_acc_ix = spl_token::instruction::close_account(\n            token_program.key,\n            pdas_temp_token_account.key,\n            initializers_main_account.key,\n            &pda,\n            &[&pda],\n        )?;\n        msg!("Calling the token program to close pda\'s temp account...");\n        invoke_signed(\n            &close_pdas_temp_acc_ix,\n            &[\n                pdas_temp_token_account.clone(),\n                initializers_main_account.clone(),\n                pda_account.clone(),\n                token_program.clone(),\n            ],\n            &[&[&b"escrow"[..], &[nonce]]],\n        )?;\n\n        msg!("Closing the escrow account...");\n        **initializers_main_account.try_borrow_mut_lamports()? = initializers_main_account\n            .lamports()\n            .checked_add(escrow_account.lamports())\n            .ok_or(EscrowError::AmountOverflow)?;\n        **escrow_account.try_borrow_mut_lamports()? = 0;\n        *escrow_account.try_borrow_mut_data()? = &mut [];\n\n        Ok(())\n    }\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"As you can see... things are much simpler with Cruiser than with vanilla Solana"))),(0,a.kt)("p",null,"If you'd like to use Cruiser in your next Solana project, please check it out on ",(0,a.kt)("a",{parentName:"p",href:"https://crates.io/crates/cruiser"},"Crates.io")))}m.isMDXComponent=!0}}]);