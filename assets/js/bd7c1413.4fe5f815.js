"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[3998],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9232:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return p}});var a=n(3117),i=n(102),r=(n(7294),n(3905)),o=["components"],l={},s="Instructions",u={unversionedId:"cruiser/walkthrough/instructions/instructions",id:"cruiser/walkthrough/instructions/instructions",title:"Instructions",description:"After designing how the data looks in our program we can spec out our instructions. We'll need _ instructions to do what we want to do, outlined here:",source:"@site/docs/cruiser/walkthrough/instructions/instructions.md",sourceDirName:"cruiser/walkthrough/instructions",slug:"/cruiser/walkthrough/instructions/",permalink:"/docs/cruiser/walkthrough/instructions/",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/walkthrough/instructions/instructions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Accounts",permalink:"/docs/cruiser/walkthrough/Accounts"},next:{title:"Create Profile",permalink:"/docs/cruiser/walkthrough/instructions/Create Profile"}},c={},p=[{value:"PDAs",id:"pdas",level:2},{value:"<code>src/pda.rs</code>",id:"srcpdars",level:3},{value:"<code>instructions</code> mod",id:"instructions-mod",level:2},{value:"<code>src/instructions/mod.rs</code>",id:"srcinstructionsmodrs",level:3},{value:"Creating the instructions",id:"creating-the-instructions",level:2},{value:"Data",id:"data",level:3},{value:"Return Type",id:"return-type",level:3},{value:"Accounts",id:"accounts",level:3},{value:"What the traits look like",id:"what-the-traits-look-like",level:2},{value:"<code>AccountArgument</code>",id:"accountargument",level:3},{value:"<code>FromAccounts</code>",id:"fromaccounts",level:3},{value:"<code>ValidateArgument</code>",id:"validateargument",level:3},{value:"Derivations",id:"derivations",level:2},{value:"Next Steps",id:"next-steps",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"instructions"},"Instructions"),(0,r.kt)("p",null,"After designing how the data looks in our program we can spec out our instructions. We'll need _ instructions to do what we want to do, outlined here:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create Profile: Creates a new player profile."),(0,r.kt)("li",{parentName:"ul"},"Create Game: Creates a new game."),(0,r.kt)("li",{parentName:"ul"},"Join Game: Joins a proposed game."),(0,r.kt)("li",{parentName:"ul"},"Forfeit Game: This will handle if your opponent doesn't respond in time."),(0,r.kt)("li",{parentName:"ul"},"Make Move: This will handle making moves and winning.")),(0,r.kt)("p",null,"I don't claim this is the best instruction design to use, but it should be enough to get you started."),(0,r.kt)("h2",{id:"pdas"},"PDAs"),(0,r.kt)("p",null,"Before we go further we will need to define our PDAs for the game signer that holds the wager. Add the following to ",(0,r.kt)("inlineCode",{parentName:"p"},"lib.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub mod pda;\n")),(0,r.kt)("p",null,"Then we can create the pda seeders"),(0,r.kt)("h3",{id:"srcpdars"},(0,r.kt)("inlineCode",{parentName:"h3"},"src/pda.rs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"//! PDAs for the program.\n\nuse cruiser::prelude::*;\n\n/// The static seed for [`GameSignerSeeder`].\npub const GAME_SIGNER_SEED: &str = \"game_signer\";\n\n/// The seeder for the game signer.\n/// \n/// We use a seeder to create type safe PDA definitions that can't accidentally be switched around or mis-set.\n#[derive(Debug, Clone)]\npub struct GameSignerSeeder {\n    /// The game's key.\n    pub game: Pubkey,\n}\nimpl PDASeeder for GameSignerSeeder {\n    fn seeds<'a>(&'a self) -> Box<dyn Iterator<Item = &'a dyn PDASeed> + 'a> {\n        // We need to return a list of seeds. This means you can order your seeds however you want.\n        // You can also use anything that implements `PDASeed` directly, even your own types.\n        Box::new([&GAME_SIGNER_SEED as &dyn PDASeed, &self.game].into_iter())\n    }\n}\n")),(0,r.kt)("h2",{id:"instructions-mod"},(0,r.kt)("inlineCode",{parentName:"h2"},"instructions")," mod"),(0,r.kt)("p",null,"Next we'll add in the ",(0,r.kt)("inlineCode",{parentName:"p"},"instructions")," module. This requires we add the following to the top of ",(0,r.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub mod instructions;\n")),(0,r.kt)("h3",{id:"srcinstructionsmodrs"},(0,r.kt)("inlineCode",{parentName:"h3"},"src/instructions/mod.rs")),(0,r.kt)("p",null,"Uncomment out the imports as we add the files."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"//! Instructions for the program.\n\n// mod create_profile;\n// mod create_game;\n// mod join_game;\n// mod make_move;\n// mod forfeit_game;\n// \n// pub use create_profile::*;\n// pub use create_game::*;\n// pub use join_game::*;\n// pub use make_move::*;\n// pub use forfeit_game::*;\n")),(0,r.kt)("h2",{id:"creating-the-instructions"},"Creating the instructions"),(0,r.kt)("p",null,"Before we create the instructions we need to go over the anatomy of a cruiser instruction. An instruction is composed of 3 different type, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Accounts"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Data"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"ReturnType"),". These types are combined through the ",(0,r.kt)("inlineCode",{parentName:"p"},"Instruction")," trait which is defined as: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// An instruction for a program with it's accounts and data.\npub trait Instruction<AI>: Sized {\n    /// The account argument for this instruction.\n    type Accounts;\n    /// The instruction data minus the instruction discriminant.\n    type Data;\n    /// The return type of the instruction\n    type ReturnType: ReturnValue;\n}\n")),(0,r.kt)("p",null,"This is usually implemented for unit structs (ie ",(0,r.kt)("inlineCode",{parentName:"p"},"struct Foo;"),")."),(0,r.kt)("h3",{id:"data"},"Data"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Data")," is the simplest, it's any type that implements ",(0,r.kt)("inlineCode",{parentName:"p"},"BorshDeserialize")," and is the data that comes in from the instruction data of the transaction. "),(0,r.kt)("h3",{id:"return-type"},"Return Type"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ReturnType")," is a little more complex than ",(0,r.kt)("inlineCode",{parentName:"p"},"Data")," by also requiring ",(0,r.kt)("inlineCode",{parentName:"p"},"BorshSerialize"),". It's the returned data to the caller in the case of CPI. The data serialization and deserialization is handled by cruiser internally. ",(0,r.kt)("inlineCode",{parentName:"p"},"Accounts")," is the most complicated."),(0,r.kt)("h3",{id:"accounts"},"Accounts"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Accounts")," requirement is the implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountArgument"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidateArgument"),". The flow is as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Instruction discriminant is deserialized (handled by the ",(0,r.kt)("inlineCode",{parentName:"li"},"InstructionList"),")."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Instruction::Data")," data is deserialized."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"InstructionProcessor::data_to_instruction_arg")," is called to split the data to from, validate, and the instruction processor."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts")," is called to build the account argument."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"ValidateArgument")," is called to validate the account argument. This is a separate step because during ",(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts")," the later accounts are not constructed and can't be referenced."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"InstructionProcessor::process")," is called to do the actual action of the instruction."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"AccountArgument::write_back")," is called to do any necessary cleanup.")),(0,r.kt)("h2",{id:"what-the-traits-look-like"},"What the traits look like"),(0,r.kt)("h3",{id:"accountargument"},(0,r.kt)("inlineCode",{parentName:"h3"},"AccountArgument")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AccountArgument")," is a parent trait defined like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// An argument that can come from [`AccountInfo`](crate::AccountInfo)s and data using [`FromAccounts`].\n/// Can be automatically derived.\npub trait AccountArgument: Sized {\n    /// The account info type this deals with\n    type AccountInfo;\n\n    /// The final step in the instruction lifecycle, performing any cleanup operations or writes back.\n    fn write_back(self, program_id: &Pubkey) -> CruiserResult<()>;\n    /// Passes all the account keys to a given function.\n    fn add_keys(&self, add: impl FnMut(Pubkey) -> CruiserResult<()>) -> CruiserResult<()>;\n    /// Collects all the account keys into a [`Vec`].\n    fn keys(&self) -> CruiserResult<Vec<Pubkey>> {\n        let mut out = Vec::new();\n        self.add_keys(|key| {\n            out.push(key);\n            Ok(())\n        })?;\n        Ok(out)\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AccountInfo")," is the account info type the argument will deal with. ",(0,r.kt)("inlineCode",{parentName:"p"},"write_back")," handles clean-up at the end and is where any final operations will occur. ",(0,r.kt)("inlineCode",{parentName:"p"},"add_keys")," is a helper function to collect all the keys in the type."),(0,r.kt)("h3",{id:"fromaccounts"},(0,r.kt)("inlineCode",{parentName:"h3"},"FromAccounts")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts")," is a trait that is used to convert raw account infos into the type. It's defined like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// Allows an account argument to be made from the account iterator and data `Arg`.\n/// `AI` is the [`AccountInfo`](crate::AccountInfo) type.\n/// This is the first step in the instruction lifecycle.\npub trait FromAccounts<Arg = ()>: Sized + AccountArgument {\n    /// Creates this argument from an `AI` iterator and data `Arg`.\n    /// - `program_id` is the current program's id.\n    /// - `infos` is the iterator of `AI`s\n    /// - `arg` is the data argument\n    fn from_accounts(\n        program_id: &Pubkey,\n        infos: &mut impl AccountInfoIterator<Item = Self::AccountInfo>,\n        arg: Arg,\n    ) -> CruiserResult<Self>;\n\n    /// A hint as to the number of accounts that this will use when [`FromAccounts::from_accounts`] is called.\n    /// Returns `(lower_bound, upper_bound)` where `lower_bound` is the minimum and `upper_bound` is the maximum or [`None`] if there is no maximum.\n    ///\n    /// Should only be used as an optimization hint, not relied on.\n    ///\n    /// A default return of `(0, None)` is valid for all although may not be as accurate as possible.\n    // TODO: Make this const once const trait functions are stabilized\n    // TODO: Figure out how to make this derivable\n    #[must_use]\n    fn accounts_usage_hint(arg: &Arg) -> (usize, Option<usize>);\n}\n\n/// A globing trait for an account info iterator\npub trait AccountInfoIterator: Iterator + DoubleEndedIterator + FusedIterator {}\nimpl<T> AccountInfoIterator for T where T: Iterator + DoubleEndedIterator + FusedIterator {}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts")," takes an ",(0,r.kt)("inlineCode",{parentName:"p"},"Arg")," type parameter that defines what extra data is needed to help build the argument. This can also be implemented multiple times for the same type with different arg types. This allows a single type to perform many roles such as being able to init itself or run checks only on certain data."),(0,r.kt)("h3",{id:"validateargument"},(0,r.kt)("inlineCode",{parentName:"h3"},"ValidateArgument")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ValidateArgument")," is a trait that is used to validate the type while being able to reference all the other arguments in the struct because it happens after everything is built. It's defined like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\n/// Validates this argument using data `Arg`. The seconds step in the instruction lifecycle.\npub trait ValidateArgument<Arg = ()>: Sized + AccountArgument {\n    /// Runs validation on this account with data `Arg`.\n    ///\n    /// Ordering for wrapping should be to call `validate` on the wrapped type first.\n    fn validate(&mut self, program_id: &Pubkey, arg: Arg) -> CruiserResult<()>;\n}\n")),(0,r.kt)("p",null,"This has the same arg parameter as ",(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts")," with the same advantages."),(0,r.kt)("h2",{id:"derivations"},"Derivations"),(0,r.kt)("p",null,"All these traits can be manually implemented without lost functionality but they are designed to be easy to automatically derive. In order to do this we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountArgument")," derive macro:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\npub struct MyArgument<AI>(pub AI);\n")),(0,r.kt)("p",null,"This is the simplest form of derivation so let's break it down."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#[derive(AccountArgument)]"),": This is the call to the derive macro."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#[account_argument()]"),": This is a set of additional arguments for the macro."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"account_info = AI"),": This is how we tell the macro what AccountInfo type to use. If we wanted to don't have to use a generic and can instead select a specific account info type, but this limits us when building clients and integrating with other frameworks."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"generics = [where AI: AccountInfo]"),": This section allows us to add additional generic requirements to the derivation of ",(0,r.kt)("inlineCode",{parentName:"li"},"AccountArgument")," and all sub-traits. The reason it's wrapped in brackets is to help with token differentiation. If we want to add additional generics (such as for ",(0,r.kt)("inlineCode",{parentName:"li"},"ToSolanaAccountInfo"),") we can do so like this: ",(0,r.kt)("inlineCode",{parentName:"li"},"generics = [<'a> where AI: ToSolanaAccountInfo<'a>]"),".")),(0,r.kt)("p",null,"By default the derive macro will pass in the unit type ",(0,r.kt)("inlineCode",{parentName:"p"},"()")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"Arg")," type for both ",(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidateArgument"),". Later we'll see how we can set this ourselves."),(0,r.kt)("p",null,"We can also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountArgument")," derive macro on more complex types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\npub struct MyArgumentComplex<AI>{\n    account1: AI,\n    account2: AI,\n    optional_account3: Option<AI>,\n    rest_of_accounts: Rest<AI>,\n}\n")),(0,r.kt)("p",null,"This uses the common ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," type as well as the cruiser ",(0,r.kt)("inlineCode",{parentName:"p"},"Rest")," type. The exact details of these can be found in their respective reference sections but here's a quick overview:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Option<T>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts<()> where T: FromAccounts<()>"),": The option will be filled if there is an account available, otherwise will be ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts<bool> where T: FromAccounts<()>"),": The option will take an account if the argument is ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", otherwise it will be ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts<(Arg,)> where T: FromAccounts<Arg>"),": The option will do the same thing as ",(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts<()>")," but will pass the arg to the inner type."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts<Option<Arg>> where T: FromAccounts<Arg>"),": The option will be filled if the argument is ",(0,r.kt)("inlineCode",{parentName:"li"},"Some(Arg)")," using the arg on the inner type, otherwise it will be ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ValidateArgument")," is cloned from the inner type and only run if the option is filled."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Rest<T>"),": Will pull all the rest of the accounts from the list as a vector of accounts.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"MyArgumentComplex")," will pull the first 2 accounts as ",(0,r.kt)("inlineCode",{parentName:"p"},"account1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"account2"),". Then if there is a third account it will be put in ",(0,r.kt)("inlineCode",{parentName:"p"},"optional_account3"),". Any remaining accounts will be put in ",(0,r.kt)("inlineCode",{parentName:"p"},"rest_of_accounts"),". Let's say we want ",(0,r.kt)("inlineCode",{parentName:"p"},"optional_account3"),"'s fullness to be determined by instruction data rather than account presence. Looking at the list of impls on ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<T>")," we can see that we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts<bool>")," trait to do this. Here's how we do it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[from(data = (fill_optional_account3: bool))]\npub struct MyArgumentComplex<AI>{\n    account1: AI,\n    account2: AI,\n    #[from(data = fill_optional_account3)]\n    optional_account3: Option<AI>,\n    rest_of_accounts: Rest<AI>,\n}\n")),(0,r.kt)("p",null,"There is some new syntax here so let's go over it:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#[from(data = fill_optional_account3)]"),": This sets the arg for the ",(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts")," impl. The data field is a tuple of the form ",(0,r.kt)("inlineCode",{parentName:"li"},"($(<field_name>: <field_type>),*)"),". The ",(0,r.kt)("inlineCode",{parentName:"li"},"field_name")," is the name to bind the argument to and the ",(0,r.kt)("inlineCode",{parentName:"li"},"field_type")," is the type that it will come in as."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#[from(data = fill_optional_account3)]"),": This sets the argument we pass to ",(0,r.kt)("inlineCode",{parentName:"li"},"optional_account3"),"'s ",(0,r.kt)("inlineCode",{parentName:"li"},"FromAccounts")," impl.")),(0,r.kt)("p",null,"We can also use similar syntax for the ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidateArgument")," trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[from(data = (fill_optional_account3: bool))]\n#[validate(data = (validate1: Arg), generics = [<Arg> where CustomValidation<AI>: ValidateArgument<Arg>])]\npub struct MyArgumentComplex<AI> {\n    #[validate(data = validate1)]\n    account1: CustomValidation<AI>,\n    #[validate(signer)]\n    account2: AI,\n    #[from(data = fill_optional_account3)]\n    optional_account3: Option<AI>,\n    rest_of_accounts: Rest<AI>,\n}\n")),(0,r.kt)("p",null,"As you can see the syntax is nearly the same, I just threw some more stuff in that I'll explain now:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"generics = [<Arg> where CustomValidation: ValidateArgument<Arg>]"),": This allows us to use generics in the argument positions, very helpful!"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#[validate(signer)]"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"validate")," has a few special functions that can be used:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signer"),": This verifies the account is a signer.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"naked ",(0,r.kt)("inlineCode",{parentName:"li"},"signer")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"MultiIndexable<()>"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signer(<arg>)")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"MultiIndexable<typeof arg>"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"writable"),": This verifies the account is writable.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"naked ",(0,r.kt)("inlineCode",{parentName:"li"},"writable")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"MultiIndexable<()>"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"writable(<arg>)")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"MultiIndexable<typeof arg>"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"owner = <pubkey>"),": This verifies the account is the owner of the argument.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"naked ",(0,r.kt)("inlineCode",{parentName:"li"},"owner = <pubkey>")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"MultiIndexable<()>"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"owner(<arg>) = <pubkey>")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"MultiIndexable<typeof arg>"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key = <pubkey>"),": This verifies the account is the key given.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"naked ",(0,r.kt)("inlineCode",{parentName:"li"},"key = <pubkey>")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"SingleIndexable<()>"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key(<arg>) = <pubkey>")," requires the argument impl ",(0,r.kt)("inlineCode",{parentName:"li"},"SingleIndexable<typeof arg>"),".")))))),(0,r.kt)("p",null,"Since multiple impls of ",(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidateArgument")," are possible the derive macro allows implementing them multiple times. This is done through the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[from(id = if_present, data = ())]\n#[from(data = (fill_optional_account3: bool))]\n#[validate(data = (validate1: Arg), generics = [<Arg> where CustomValidation<AI>: ValidateArgument<Arg>])]\npub struct MyArgumentComplex<AI> {\n    #[validate(data = validate1)]\n    account1: CustomValidation<AI>,\n    #[validate(signer)]\n    account2: AI,\n    #[from(id = if_present)]\n    #[from(data = fill_optional_account3)]\n    optional_account3: Option<AI>,\n    rest_of_accounts: Rest<AI>,\n}\n")),(0,r.kt)("p",null,"By default, the unit type version is not implemented if another type is added but as can be seen above the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," can be used to still implement this. The attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"#[from(id = if_present)]")," is not strictly necessary because by default the unit type is passed."),(0,r.kt)("p",null,"Should you wish to not implement any ",(0,r.kt)("inlineCode",{parentName:"p"},"FromAccounts")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidateArgument")," traits (usually because you want to do it manually) you can do so by adding ",(0,r.kt)("inlineCode",{parentName:"p"},"no_from")," and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"no_validate")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"account_argument")," attribute:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(AccountArgument)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo], no_from, no_validate)]\npub struct MyArgumentComplex<AI> {\n    account1: CustomValidation<AI>,\n    account2: AI,\n    optional_account3: Option<AI>,\n    rest_of_accounts: Rest<AI>,\n}\n")),(0,r.kt)("h2",{id:"next-steps"},"Next Steps"),(0,r.kt)("p",null,"Next we will create each instruction and explain further principles with each."))}m.isMDXComponent=!0}}]);