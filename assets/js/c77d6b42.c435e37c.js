"use strict";(self.webpackChunkidentity_docs=self.webpackChunkidentity_docs||[]).push([[8051],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return f}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var u=r.createContext({}),c=function(e){var n=r.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=c(e.components);return r.createElement(u.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=c(t),f=a,d=p["".concat(u,".").concat(f)]||p[f]||m[f]||o;return t?r.createElement(d,i(i({ref:n},l),{},{components:t})):r.createElement(d,i({ref:n},l))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=p;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5249:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return m}});var r=t(3117),a=t(102),o=(t(7294),t(3905)),i=["components"],s={sidebar_position:4,title:"Forfeit Game"},u="Forfeit Game",c={unversionedId:"cruiser/walkthrough/instructions/forfeit_game",id:"cruiser/walkthrough/instructions/forfeit_game",title:"Forfeit Game",description:"Our next instruction will be forfeiting an abandoned game. This can be called by a player when it has been the opposing player's turn for longer than Game::turnlength to 0.",source:"@site/docs/cruiser/walkthrough/instructions/forfeit_game.md",sourceDirName:"cruiser/walkthrough/instructions",slug:"/cruiser/walkthrough/instructions/forfeit_game",permalink:"/docs/cruiser/walkthrough/instructions/forfeit_game",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cruiser/walkthrough/instructions/forfeit_game.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Forfeit Game"},sidebar:"tutorialSidebar",previous:{title:"Join Game",permalink:"/docs/cruiser/walkthrough/instructions/Join Game"},next:{title:"Make Move",permalink:"/docs/cruiser/walkthrough/instructions/make_move"}},l={},m=[{value:"Definition",id:"definition",level:2},{value:"Processor",id:"processor",level:2},{value:"Add to <code>InstructionList</code>",id:"add-to-instructionlist",level:2},{value:"CPI",id:"cpi",level:2},{value:"Client",id:"client",level:2},{value:"Tests",id:"tests",level:2}],p={toc:m};function f(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"forfeit-game"},"Forfeit Game"),(0,o.kt)("p",null,"Our next instruction will be forfeiting an abandoned game. This can be called by a player when it has been the opposing player's turn for longer than ",(0,o.kt)("inlineCode",{parentName:"p"},"Game::turn_length"),". This makes sure players can't lock up the wagers by not playing. Players can also ignore this if they want by setting ",(0,o.kt)("inlineCode",{parentName:"p"},"Game::turn_length")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,o.kt)("p",null,"The main new topic for this is closing accounts which is done on solana by draining all of their lamports. In ",(0,o.kt)("inlineCode",{parentName:"p"},"cruiser")," this is easily done by wrapping the account with ",(0,o.kt)("inlineCode",{parentName:"p"},"CloseAccount"),". "),(0,o.kt)("p",null,"When closing an account make sure the data is put into a state that makes the account unusable because unless you do instruction checking (not suggested for composability) a malicious user could add an instruction that transfers lamports to the account that was attempted to be closed or otherwise use it in the same transaction. The reason is that accounts are cleaned up at the end of the transaction so this could be an attack vector."),(0,o.kt)("h2",{id:"definition"},"Definition"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::accounts::Player;\nuse crate::pda::GameSignerSeeder;\nuse crate::{Game, PlayerProfile, TutorialAccounts};\nuse cruiser::prelude::*;\nuse cruiser::solana_program::clock::Clock;\n\n/// Causes another player to forfeit the game if they run out of time for their turn.\n#[derive(Debug)]\npub enum ForfeitGame {}\n\nimpl<AI> Instruction<AI> for ForfeitGame {\n    type Accounts = ForfeitGameAccounts<AI>;\n    type Data = ForfeitGameData;\n    type ReturnType = ();\n}\n\n/// Accounts for [`ForfeitGame`]\n#[derive(AccountArgument, Debug)]\n#[account_argument(account_info = AI, generics = [where AI: AccountInfo])]\n#[validate(generics = [<'a> where AI: ToSolanaAccountInfo<'a>])]\npub struct ForfeitGameAccounts<AI> {\n    /// The authority of the player calling the forfeit.\n    #[validate(signer)]\n    pub authority: AI,\n    /// The profile of the calling player.\n    #[validate(custom = &self.player_profile.authority == self.authority.key())]\n    pub player_profile: DataAccount<AI, TutorialAccounts, PlayerProfile>,\n    /// The other player's profile.\n    pub other_profile: DataAccount<AI, TutorialAccounts, PlayerProfile>,\n    /// The game the other player has forfeited.\n    #[validate(\n        custom = self.game.turn_length == 0\n            || self.game.last_turn.saturating_add(self.game.turn_length) < Clock::get()?.unix_timestamp,\n        custom = match self.game.next_play {\n            Player::One => self.player_profile.info().key() == &self.game.player2,\n            Player::Two => self.player_profile.info().key() == &self.game.player1,\n        },\n        custom = match self.game.next_play {\n            Player::One => self.other_profile.info().key() == &self.game.player1,\n            Player::Two => self.other_profile.info().key() == &self.game.player2,\n        },\n    )]\n    pub game: Box<CloseAccount<AI, DataAccount<AI, TutorialAccounts, Game>>>,\n    /// The game's signer.\n    #[validate(writable, data = (GameSignerSeeder{ game: *self.game.info().key() }, self.game.signer_bump))]\n    pub game_signer: Seeds<AI, GameSignerSeeder>,\n    /// Where the funds should go to.\n    #[validate(writable)]\n    pub funds_to: AI,\n    /// The system program\n    pub system_program: SystemProgram<AI>,\n}\n\n/// Data for [`ForfeitGame`]\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]\npub struct ForfeitGameData {}\n")),(0,o.kt)("p",null,"Here we can see the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"CloseAccount")," on ",(0,o.kt)("inlineCode",{parentName:"p"},"game"),"."),(0,o.kt)("h2",{id:"processor"},"Processor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(feature = "processor")]\nmod processor {\n    use super::*;\n    use crate::accounts::update_elo;\n    use std::iter::once;\n\n    impl<\'a, AI> InstructionProcessor<AI, ForfeitGame> for ForfeitGame\n    where\n        AI: ToSolanaAccountInfo<\'a>,\n    {\n        type FromAccountsData = ();\n        type ValidateData = ();\n        type InstructionData = ();\n\n        fn data_to_instruction_arg(\n            _data: <ForfeitGame as Instruction<AI>>::Data,\n        ) -> CruiserResult<(\n            Self::FromAccountsData,\n            Self::ValidateData,\n            Self::InstructionData,\n        )> {\n            Ok(((), (), ()))\n        }\n\n        fn process(\n            _program_id: &Pubkey,\n            _data: Self::InstructionData,\n            accounts: &mut <ForfeitGame as Instruction<AI>>::Accounts,\n        ) -> CruiserResult<<ForfeitGame as Instruction<AI>>::ReturnType> {\n            // Get the seeds out of the signer account\n            let signer_seeds = accounts.game_signer.take_seed_set().unwrap();\n\n            msg!("Transferring");\n            // Need to separate this out because it will cause a borrow error if done in-line.\n            // Can also be avoided with `CPIUnchecked`\n            let transfer_amount = *accounts.game_signer.lamports();\n            // Transfer wager to forfeit-eer\n            accounts.system_program.transfer(\n                CPIChecked,\n                accounts.game_signer.info(),\n                &accounts.funds_to,\n                transfer_amount,\n                once(&signer_seeds),\n            )?;\n\n            msg!("Setting fields");\n            // Zero out the players so the game is dead.\n            // We will close the game but this prevents it from being re-opened in the same transaction and still being useful.\n            accounts.game.player1 = SystemProgram::<()>::KEY;\n            accounts.game.player2 = SystemProgram::<()>::KEY;\n\n            // Set who gets the funds on close\n            accounts.game.set_fundee(accounts.funds_to.clone());\n\n            accounts\n                .player_profile\n                .lamports_won\n                .saturating_add_assign(accounts.game.wager);\n            accounts.player_profile.wins.saturating_add_assign(1);\n\n            accounts\n                .other_profile\n                .lamports_lost\n                .saturating_add_assign(accounts.game.wager);\n            accounts.other_profile.losses.saturating_add_assign(1);\n\n            update_elo(\n                &mut accounts.player_profile.elo,\n                &mut accounts.other_profile.elo,\n                50.0, // 50 for forfeits to discourage them\n                true,\n            );\n\n            Ok(())\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Here we can see that the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"CloseAccount")," requires a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"set_fundee")," to tell where the funds go to on close. We also zero out the player accounts to burn the data in the account."),(0,o.kt)("h2",{id:"add-to-instructionlist"},"Add to ",(0,o.kt)("inlineCode",{parentName:"h2"},"InstructionList")),(0,o.kt)("p",null,"Add the following to ",(0,o.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, InstructionList, Copy, Clone)]\n#[instruction_list(\n    account_list = TutorialAccounts,\n    account_info = [<'a, AI> AI where AI: ToSolanaAccountInfo<'a>],\n    discriminant_type = u8,\n)]\npub enum TutorialInstructions {\n    /// Creates a new player profile.\n    #[instruction(instruction_type = instructions::CreateProfile)]\n    CreateProfile,\n    /// Create a new game.\n    #[instruction(instruction_type = instructions::CreateGame)]\n    CreateGame,\n    /// Join a game.\n    #[instruction(instruction_type = instructions::JoinGame)]\n    JoinGame,\n    /// Forfeits another player from a game\n    #[instruction(instruction_type = instructions::ForfeitGame)]\n    ForfeitGame,\n}\n")),(0,o.kt)("h2",{id:"cpi"},"CPI"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(feature = \"cpi\")]\npub use cpi::*;\n\n/// CPI for [`ForfeitGame`]\n#[cfg(feature = \"cpi\")]\nmod cpi {\n    use super::*;\n    use crate::TutorialInstructions;\n\n    /// Forfiets another player from a game.\n    #[derive(Debug)]\n    pub struct ForfeitGameCPI<'a, AI> {\n        accounts: [MaybeOwned<'a, AI>; 7],\n        data: Vec<u8>,\n    }\n    impl<'a, AI> ForfeitGameCPI<'a, AI> {\n        /// Forfiets another player from a game.\n        pub fn new(\n            authority: impl Into<MaybeOwned<'a, AI>>,\n            player_profile: impl Into<MaybeOwned<'a, AI>>,\n            other_profile: impl Into<MaybeOwned<'a, AI>>,\n            game: impl Into<MaybeOwned<'a, AI>>,\n            game_signer: impl Into<MaybeOwned<'a, AI>>,\n            funds_to: impl Into<MaybeOwned<'a, AI>>,\n            system_program: impl Into<MaybeOwned<'a, AI>>,\n        ) -> CruiserResult<Self> {\n            let mut data = Vec::new();\n            <TutorialInstructions as InstructionListItem<ForfeitGame>>::discriminant_compressed()\n                .serialize(&mut data)?;\n            ForfeitGameData {}.serialize(&mut data)?;\n            Ok(Self {\n                accounts: [\n                    authority.into(),\n                    player_profile.into(),\n                    other_profile.into(),\n                    game.into(),\n                    game_signer.into(),\n                    funds_to.into(),\n                    system_program.into(),\n                ],\n                data,\n            })\n        }\n    }\n\n    impl<'a, AI> CPIClientStatic<'a, 8> for ForfeitGameCPI<'a, AI>\n    where\n        AI: ToSolanaAccountMeta,\n    {\n        type InstructionList = TutorialInstructions;\n        type Instruction = ForfeitGame;\n        type AccountInfo = AI;\n\n        fn instruction(\n            self,\n            program_account: impl Into<MaybeOwned<'a, Self::AccountInfo>>,\n        ) -> InstructionAndAccounts<[MaybeOwned<'a, Self::AccountInfo>; 8]> {\n            let program_account = program_account.into();\n            let instruction = SolanaInstruction {\n                program_id: *program_account.meta_key(),\n                accounts: self\n                    .accounts\n                    .iter()\n                    .map(MaybeOwned::as_ref)\n                    .map(AI::to_solana_account_meta)\n                    .collect(),\n                data: self.data,\n            };\n            let mut accounts = self.accounts.into_iter();\n            InstructionAndAccounts {\n                instruction,\n                accounts: [\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    accounts.next().unwrap(),\n                    program_account,\n                ],\n            }\n        }\n    }\n}\n")),(0,o.kt)("h2",{id:"client"},"Client"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(feature = "client")]\npub use client::*;\n\n/// Client for [`ForfeitGame`]\n#[cfg(feature = "client")]\nmod client {\n    use super::*;\n\n    /// Forfeits another player from a game.\n    pub fn forfeit_game<\'a>(\n        program_id: Pubkey,\n        authority: impl Into<HashedSigner<\'a>>,\n        player_profile: Pubkey,\n        other_profile: Pubkey,\n        game: Pubkey,\n        game_signer_bump: u8,\n        funds_to: Pubkey,\n    ) -> InstructionSet<\'a> {\n        let authority = authority.into();\n        InstructionSet {\n            instructions: vec![\n                ForfeitGameCPI::new(\n                    SolanaAccountMeta::new_readonly(authority.pubkey(), true),\n                    SolanaAccountMeta::new(player_profile, false),\n                    SolanaAccountMeta::new(other_profile, false),\n                    SolanaAccountMeta::new(game, false),\n                    SolanaAccountMeta::new(\n                        GameSignerSeeder { game }\n                            .create_address(&program_id, game_signer_bump)\n                            .unwrap(),\n                        false,\n                    ),\n                    SolanaAccountMeta::new(funds_to, false),\n                    SolanaAccountMeta::new_readonly(SystemProgram::<()>::KEY, false),\n                )\n                .unwrap()\n                .instruction(SolanaAccountMeta::new_readonly(program_id, false))\n                .instruction,\n            ],\n            signers: [authority].into_iter().collect(),\n        }\n    }\n}\n')),(0,o.kt)("h2",{id:"tests"},"Tests"),(0,o.kt)("p",null,"Add the following to your ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/instructions/mod.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod forfeit_game;\n")),(0,o.kt)("p",null,"Then we create ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/instructions/forfeit_game.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::instructions::setup_validator;\nuse cruiser::prelude::*;\nuse cruiser_tutorial::accounts::Player;\nuse cruiser_tutorial::instructions::*;\nuse cruiser_tutorial::pda::GameSignerSeeder;\nuse std::error::Error;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\n#[tokio::test]\nasync fn forfeit_game_test() -> Result<(), Box<dyn Error>> {\n    let guard = setup_validator().await;\n\n    let rpc = guard.rpc();\n    let funder = Keypair::new();\n\n    // Airdrop SOL to the funder\n    let blockhash = rpc.get_latest_blockhash().await?;\n    let sig = rpc\n        .request_airdrop_with_blockhash(&funder.pubkey(), LAMPORTS_PER_SOL * 10, &blockhash)\n        .await?;\n    rpc.confirm_transaction_with_spinner(&sig, &blockhash, CommitmentConfig::confirmed())\n        .await?;\n\n    // Create random authority and profile\n    let authority1 = Keypair::new();\n    let profile1 = Keypair::new();\n    let authority2 = Keypair::new();\n    let profile2 = Keypair::new();\n    let game = Keypair::new();\n    let game_signer_bump = GameSignerSeeder {\n        game: game.pubkey(),\n    }\n    .find_address(&guard.program_id())\n    .1;\n\n    let (sig, result) = TransactionBuilder::new(&funder)\n        .signed_instructions(create_profile(\n            guard.program_id(),\n            &authority1,\n            &profile1,\n            &funder,\n        ))\n        .signed_instructions(create_profile(\n            guard.program_id(),\n            &authority2,\n            &profile2,\n            &funder,\n        ))\n        .signed_instructions(create_game(\n            guard.program_id(),\n            &authority1,\n            profile1.pubkey(),\n            &game,\n            &funder,\n            &funder,\n            Some(profile2.pubkey()),\n            CreateGameClientData {\n                creator_player: Player::One,\n                wager: LAMPORTS_PER_SOL,\n                turn_length: 1, // 1 second\n            },\n        ))\n        .signed_instructions(join_game(\n            guard.program_id(),\n            &authority2,\n            profile2.pubkey(),\n            game.pubkey(),\n            game_signer_bump,\n            &funder,\n        ))\n        .send_and_confirm_transaction(\n            rpc,\n            RpcSendTransactionConfig {\n                skip_preflight: false,\n                preflight_commitment: Some(CommitmentLevel::Confirmed),\n                encoding: None,\n                max_retries: None,\n            },\n            CommitmentConfig::confirmed(),\n            Duration::from_millis(500),\n        )\n        .await?;\n\n    // Check result\n    match result {\n        ConfirmationResult::Success => {}\n        ConfirmationResult::Failure(error) => return Err(error.into()),\n        ConfirmationResult::Dropped => return Err("Transaction dropped".into()),\n    }\n\n    // Print logs for debugging\n    println!(\n        "Logs: {:#?}",\n        rpc.get_transaction_with_config(\n            &sig,\n            RpcTransactionConfig {\n                encoding: None,\n                commitment: Some(CommitmentConfig::confirmed()),\n                max_supported_transaction_version: None\n            }\n        )\n        .await?\n        .transaction\n        .meta\n        .unwrap()\n        .log_messages\n    );\n\n    // Wait for game to timeout\n    // This value may need to be adjusted to be longer, we are working on very small timescales\n    sleep(Duration::from_millis(2000)).await;\n\n    let receiver = Keypair::new().pubkey();\n\n    let (sig, result) = TransactionBuilder::new(&funder)\n        .signed_instructions(forfeit_game(\n            guard.program_id(),\n            &authority2,\n            profile2.pubkey(),\n            profile1.pubkey(),\n            game.pubkey(),\n            game_signer_bump,\n            receiver,\n        ))\n        .send_and_confirm_transaction(\n            rpc,\n            RpcSendTransactionConfig {\n                skip_preflight: false,\n                preflight_commitment: Some(CommitmentLevel::Confirmed),\n                encoding: None,\n                max_retries: None,\n            },\n            CommitmentConfig::confirmed(),\n            Duration::from_millis(501),\n        )\n        .await?;\n\n    // Check result\n    match result {\n        ConfirmationResult::Success => {}\n        ConfirmationResult::Failure(error) => return Err(error.into()),\n        ConfirmationResult::Dropped => return Err("Transaction dropped".into()),\n    }\n\n    // Print logs for debugging\n    println!(\n        "Logs: {:#?}",\n        rpc.get_transaction_with_config(\n            &sig,\n            RpcTransactionConfig {\n                encoding: None,\n                commitment: Some(CommitmentConfig::confirmed()),\n                max_supported_transaction_version: None\n            }\n        )\n        .await?\n        .transaction\n        .meta\n        .unwrap()\n        .log_messages\n    );\n\n    let accounts = rpc\n        .get_multiple_accounts_with_commitment(\n            &[game.pubkey(), receiver],\n            CommitmentConfig::confirmed(),\n        )\n        .await?\n        .value;\n    if let Some(game) = &accounts[0] {\n        assert_eq!(game.lamports, 0);\n        assert_eq!(game.owner, SystemProgram::<()>::KEY);\n    }\n    let receiver = accounts[1].as_ref().unwrap();\n    assert!(receiver.lamports > LAMPORTS_PER_SOL * 2);\n\n    guard.drop_self().await;\n    Ok(())\n}\n')),(0,o.kt)("p",null,"This test should execute without error. To run it you can either run ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo test --features client --test all_tests instructions::forfeit_game::forfeit_game_test -- --exact")," to run only this test."))}f.isMDXComponent=!0}}]);